### 목차

- [HTTP 메세지](#http-메세지)
  - [학습 목표](#학습-목표)
- [메세지의 흐름](#메세지의-흐름)
- [메세지의 각 부분](#메세지의-각-부분)
  - [메세지 문법](#메세지-문법)
  - [시작줄](#시작줄)
- [메소드](#메소드)
  - [안전한 메소드](#안전한-메소드)
- [상태 코드](#상태-코드)
- [헤더](#헤더)
  - [일반 헤더](#일반-헤더)
  - [요청 헤더](#요청-헤더)
  - [응답 헤더](#응답-헤더)
  - [엔티티 헤더](#엔티티-헤더)


### HTTP 메세지

#### 학습 목표
- HTTP 메세지가 어떻게 흘러가는가
- HTTP 메세지의 세 부분 (시작줄, 헤더, 개체 본문)
- 요청과 응답 메세지의 차이
- 요청 메세지가 지원하는 여러 기능들
- 응답 메세지가 반환하는 여러 상태코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

##

### 메세지의 흐름
HTTP 메세지는 HTTP 애플리케이션 간에 주고받은 데이터 블록이다.

이때 메세지의 흐름을 나타내는 용어가 다음과 같이 있다.
- 인바운드: 클라이언트 -> 서버
- 아웃바운드: 서버 -> 클라이언트
- 다운스트림: 요청&응답 메세지와 관계없이 아래로 흐른다는 뜻
  ![2025  7  29  19:43 Microsoft Lens](https://github.com/user-attachments/assets/fa2075ff-cd63-435c-8292-2ef15cc466f7)

<br>

### 메세지의 각 부분
HTTP 메세지는 단순 데이터의 구조화된 블록으로 시작줄, 헤더, 본문으로 이루어진다.

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열로 이때 빈줄(줄바꿈 문자열)은 `CRLF`라 쓴다.

#### 메세지 문법

요청 메세지의 형식은 다음과 같다.

```
<메소드> <요청 URL> <버전>
<헤더>

<엔티티 본문>
```

<br>

응답 메세지의 형식은 다음과 같다.
```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔티티 본문>
```

여기서 사용되는 <버전>의 HTTP 버전은 `HTTP/x.y` 형식으로 요청/응답 양쪽에서 모두 사용하고, 이는 HTTP로 대화하는 애플리케이션 간의 상대 능력과 메세지 형식에 대한 단서로 활용된다.

예를 들어 `HTTP/1.1`로 응답을 받았을 때를 해석해보면, 응답을 보낸 서버의 HTTP 버전은 1.1까지 이해할 수 있다는 의미이다.

추가로, HTTP/2.22는 HTTP/3보다 큰 것으로, 버전의 각 숫자(x, y)는 분리된 숫자로 다루어야 한다.

#### 시작줄
모든 HTTP 메세지는 시작줄로 시작하며 무엇을 해야할지, 무슨 일이 일어났는지를 알려준다.

- 요청줄
  - 요청 메세지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. HTTP 요청 메소드와 요청 URL, HTTP 버전을 공백으로 구분하여 작성된다.
- 응답줄
  - 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 이때 HTTP 버전, 결과에 따른 상태코드, 서버의 피드백 구절이 들어있다.

<br>

### 메소드
- `GET`: 가장 흔히 쓰는 메소드로, 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
- `HEAD`: GET처럼 행동하지만, 본문을 갖지 않는다.
  - 리소스를 가져오지 않고도, 리소스에 대해 헤더 정보만을 알아낼 수 있음
  - 응답 상태코드를 통해 존재 여부를 확인할 수 있음
  - 헤더를 확인해 리소스의 변경 여부를 알 수 있음
- `PUT`: 서버에 문서를 쓸 수 있는 메소드로 요청 URL에 문서가 존재한다면 교체해주고, 없다면 새로 만든다.
- `POST`: 서버에 입력 데이터를 전송하기 위해 설계되었다.
- `TRACE`: 클라이언트에게 자신이 보낸 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
  - 목적지 서버에서 `루프백` 진단을 시작하고, 자신이 받은 요청 메세지를 본문에 넣어 응답으로 되돌려준다.
  - 이를 통해 자신이 보낸 메세지가 망가졌거나 수정되었는지를 확인할 수 있다.
- `OPTIONS`: 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
  - 특정 리소스에 대해 어떤 메소드가 지원되는지 물어볼 수 있다.
  - 리소스에 직접 접근 없이도 어떻게 접근할 지 알아낼 수 있다.
- `DELETE`: 서버에게 요청 URL의 리소스를 삭제할 것을 요청한다.
  - 특이사항으로 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.
  - HTTP 명세에는 서버가 클라이언트에게 알리지 않고 무시하는 것을 허용하기 때문이다.

#### 안전한 메소드
`GET`과 `HEAD`은 안전한 메소드로 불리는데, 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없기 때문이다. 작용이 없다는 것은, 해당 요청에 의해 서버가 바뀔 일이 없다는 뜻이다.

<br>

### 상태 코드
상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

- `100-199`: 정보성 상태 코드
  - HTTP/1.1 버전에서 도입되었다.
  - 100 상태코드는 '요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 이어서 보내야 함'을 의미한다.
  - 클라이언트와 서버는 100-continue를 보내고 수신했을 때, 각각에 맞는 행동을 해야 한다.
- `200-299`: 성공 상태 코드
- `300-399`: 리다이렉션 상태 코드
  - 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나, 내용 대신 다른 대안 응답을 제공한다.
  - 만약 옮겨졌다면, Location 헤더를 보내어 새 위치로 이동할 URL을 헤더에 담아 보내줄 수 있다.
  - 302, 303, 307과 같이 비슷한 상태코드들이 있는데 HTTP/1.0과 HTTP/1.1 버전에 따라 명세가 다르다.
- `400-499`: 클라이언트 에러 상태 코드
- `500-599`: 서버 에러 코드

<br>

### 헤더
헤더와 메소드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다. 그리고 헤더는 크게 다섯 가지로 분류된다.

#### 일반 헤더
메세지에 대한 기본적인 정보를 제공하는 곳으로 요청과 응답 양쪽 메세지 모두에 일반적이고, Date, MIME-Version, Connection 등이 있다.

일반 캐시 헤더는 HTTP/1.0부터 도입되어 Pragma, Cache-Control 등이 있다.

<br>

#### 요청 헤더
요청 메세지에서만 의미를 갖는 헤더로, 서버는 요청 헤더가 준 정보를 통해 더 나은 응답을 위해 활용할 수 있다.

클라이언트는 **Accept 헤더**를 이용해 서버에게 무엇을 원하고 무엇을 할 수 있는지, 원치 않는 것은 어떤 건지 알려줄 수 있다.

또한, **조건부 요청 헤더**를 활용해 클라이언트가 요청에 제약을 넣기도 한다. 예로, 어떤 문서를 클라이언트가 가지고 있다면 수정이 된 경우에만 달라고 요청할 수도 있다. `If-Modified-Since`와 `Except`등이 있다.

자체적으로 요청을 위한 **요청 보안 헤더**를 가져 인증요구/응답 체계 또한 가지고 있다. Authorization으로 인증 정보를 담거나, Cookie를 이용해 토큰을 전달할 때 사용한다.

<br>

#### 응답 헤더
응답 메세지에만 의미를 갖는 헤더로, 클라이언트에게 부가 정보를 제공한다. 누가 응답을 보내는지, 혹은 어떻게 되는지 설명 등을 해줄 수 있다.

요청과 마찬가지로 **응답 보안 헤더**가 존재하여 Set-Cookie를 활용해 클라이언트 측에 토큰을 설정하기 위해 사용할 수 있다.

<br>

#### 엔티티 헤더
요청과 응답 양쪽 모두 엔티티(= 본문)를 포함할 수 있기에, 양쪽 타입의 메세지 모두 활용될 수 있다. 내용물에 대한 개체 타입부터 시작해 요청할 수 있는 유효한 메소드까지 제공한다. 리다이렉션 상태 코드 때 나왔던 `Location`이 여기에 해당된다.

**콘텐츠 헤더**를 통해 엔티티 콘텐츠에 대한 구체적인 정보를 제공할 수 있다. 콘텐츠의 종류, 크기, 인코딩 정보 등을 포함하여 우리는 해당 헤더를 보고 그 객체를 어떻게 보여줄 지 결정할 수 있다.

**엔티티 캐싱 헤더**는 언제 어떻게 캐시가 되어야 하는지 알려주는 지시자로, 엔티티 캐싱에 대한 정보를 제공한다. 캐시된 사본이 유효한지 정보와 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 잘 추정하기 위한 단서이다. `ETag`, `Expires`, `Last-Modified` 등이 포함된다.
