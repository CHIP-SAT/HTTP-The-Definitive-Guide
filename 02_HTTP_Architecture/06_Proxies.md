### 학습목표
- HTTP 프락시와 웹 게이트웨이를 비교하고, HTTP 프락시가 어떻게 배치되는지 그림으로 보여주면서 설명한다.
- 프락시가 실제 네트워크에 어떻게 배치되어 있는지, 그리고 트래픽이 어떻게 프락시 서버로 가게 되는지 설명한다.
- 브라우저에서 프락시를 사용하려면 어떻게 설정해야 하는지 보여준다.
- HTTP 프락시 요청이 서버 요청과 어떻게 다른지, 그리고 프락시가 어떻게 브라우저의 동작을 미묘하게 바꾸는지 보여준다.
- 일련의 프락시 서버들을 통과하는 메세지의 경로들, Via 헤더와 TRACE 메소드를 이용해 기록하는 방법을 설명한다.
- 프락시에 기반한 HTTP 접근 제어를 설명한다.
- 어떻게 프락시가 클라이언트-서버 사이에서 각각의 다른 기능과 버전들을 지원하면서 상호작용하는지 설명한다.

##

### 웹 중개자
웹 프락시 서버는 클라이언트 입장에서 트랜잭션을 수행하는 '중개인'이다. 프락시가 없다면, 클라이언트는 HTTP 서버와 직접 이야기한다.

![2025  8  10  15:13 Microsoft Lens](https://github.com/user-attachments/assets/50fefd41-20c5-452e-818a-6db3cc142b27)

HTTP 프락시 서버는 웹 서버이기도 하고, 웹 클라이언트이기도 하다. 클라이언트 입장에서는 서버 역할을 하고, HTTP 서버에 보낼 때는 자신이 요청하는 클라이언트 입장이기 때문이다.

<br>

#### 개인 프락시와 공유 프락시

프락시 서버는 하나의 클라이언트가 독점할 수도 있고, 여러 클라이언트와 공유할 수도 있다. 하나의 클라이언트를 위한 것은 개인 프락시, 함께 사용하기 위한 것은 공유 프락시라고 한다.

- 공유 프락시
  - 대부분 프락시는 공유 프락시이다. 중앙 집중형 프락시로 관리하여 비용효율을 증대시킨다.
  - 캐시 프락시 서버와 같은 몇몇 프락시 앱은 사용자가 많을수록 유리한 특징을 지닌다.
- 개인 프락시
  - 많이 안 쓰인다.
  - 특정 브라우저는 ISP 서비스와 마찬가지로, 기능 확장 및 성능 개선 등을 위해 작은 프락시를 사용자의 컴퓨터에서 직접 실행한다.

<br>

#### 프락시 대 게이트웨이
- `프락시`: 서로 **같은 프로토콜을 사용하는 둘** 이상의 애플리케이션을 연결
- `게이트웨이`: 서로 **다른 프로토콜을 사용하는 둘** 이상의 애플리케이션을 연결

![2025  8  10  15:34 Microsoft Lens](https://github.com/user-attachments/assets/5a2831d6-8b34-40d6-9f4c-645e1690c2d1)

실질적으로 차이는 모호하다. 브라우저와 서버는 다른 버전의 HTTP를 구현하기 때문에, 프락시는 가끔 프로토콜 변환을 하기도 한다.

또, 프락시는 SSL 보안 프로토콜, FTP 접근, 웹 기반 애플리케이션을 위해 게이트웨이 기능을 구현하기도 한다. 자세한 건 8장에서 ㄱㄱ

##

### 왜 프락시를 사용하는가?
프락시는 보안 개선, 성능 증가, 비용 절약 등의 실용적이고 유용한 일을 한다. 또, 모든 HTTP 트래픽을 들여보고 건드릴 수 있기에 트래픽 감시 및 수정이 가능하다.

1. 어린이 필터: 잼민이 때 학교 컴퓨터로 서든어택 홈페이지 못 들어가는 것도 프락시가 필터링하기 때문이다.
2. 문서 접근 제어자: 또한, 웹 리소스 문서에 대한 접근 제어도 추적 및 감시가 가능하다.
3. 보안 방화벽: 방화벽 프락시를 통해 보안을 강화할 수 있다.
4. 웹 캐시: 인기있는 문서의 로컬 사본을 관리하고 요청이 오면 빠르게 제공하여, 커뮤니케이션을 줄여 비용을 아낀다.
5. 대리 프락시: 웹 서버인 것처럼 위장하여 공용 콘텐츠에 대한 느린 웹 서버 성능을 개선하기 위해 사용된다. 서버 가속기라고도 불림
6. 콘텐츠 라우터: 인터넷 트래픽 조건이나, 콘텐츠 종류에 따라 라우팅하는 동작을 할 수 있다.
7. 트랜스코터: 콘텐츠를 클라이언트에게 전달하기 전에 본문을 수정할 수 있다. 이런 데이터 변환을 트랜스코딩이라 함 GIF를 JPG로 변환하거나, 크기를 줄이거나 압축 등등을 한다.
8. 익명화 프락시: HTTP 메세지에서 신원을 확인할 수 있는 특성을 제거하여 정보 보호와 익명성에 기여한다. 쿠키를 없애거나 OS 종류, From 헤더 등을 제거할 수 있다.

##

### 프락시는 어디에 있는가
프락시는 어떻게 사용하느냐에 따라 어디든 배치할 수 있다.

#### 프락시 서버 배치
- **어떻게 프락시가 네트워크에 배치되는가**
    - 프락시는 사용 목적에 따라 여러 가지 방식으로 배치될 수 있음.
    - **출구 프락시**
        - 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프락시를 로컬 네트워크의 출구에 박아 넣음.
          <img width="580" height="216" alt="image" src="https://github.com/user-attachments/assets/a14fa87c-e22f-4d4c-9b8f-3144d55d4cc5" />

    - **접근 프락시**
        - 고객으로부터의 모든 요청을 종합적으로 처리하기 위해 ISP 지점에 위치
        - ISP는 사용자들의 다운로드 속도를 개선하고 인터넷 대역폭 비용을 줄이기 위해 캐시 프락시를 사용
          <img width="542" height="213" alt="image" src="https://github.com/user-attachments/assets/aee21c9c-507f-4472-9371-1d8348dd25c6" />

    - **대리 프락시**
        - 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청
        - 웹 서버에 보안 기능을 추가하거나 빠른 웹 서버 캐시를 느린 웹 서버의 앞에 놓음으로써 성능 개선
        - 대리 프락시는 일반적으로 웹 서버의 이름과 IP 주소로 스스로를 가장하기 때문에, 모든 요청은 서버가 아닌 이 프락시로 가게 됨.
          <img width="530" height="220" alt="image" src="https://github.com/user-attachments/assets/5b027356-d225-4c4c-a261-7f70209339cb" />

    - **네트워크 교환 프락시**
        - 캐시를 이용해 인터넷 교차로의 혼잡을 완화
        - 트래픽 흐름을 감시하기 위해 충분한 처리 능력을 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환 지점들에 위치
          <img width="530" height="213" alt="image" src="https://github.com/user-attachments/assets/f9cebfba-b412-4850-83f4-002b2c69f718" />

- **어떻게 프락시의 연쇄가 계층을 이루는가**
    - 프락시 계층에서 메시지는 최종적으로 원 서버에 도착할 때까지 프락시와 프락시를 거쳐 이동함.
    - 프락시 계층에서 프락시 서버들은 부모와 자식 관계를 가짐.
      <img width="521" height="200" alt="image" src="https://github.com/user-attachments/assets/08ed566b-684b-4748-a350-670e98020a73" />

    - 프락시 서버는 여러 가지 판단 근거에 의해 메시지를 다양하고 유동적인 프락시 서버와 원 서버들의 집합에 전송 가능
    - **동적 부모 선택의 예시**
        - **부하 균형**
            - 자식 프락시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고름.
        - **지리적 인접성에 근거한 라우팅**
            - 자식 프락시는 원 서버의 지역을 담당하는 부모를 선택 가능
                - 원 서버의 지역을 담당하는 부모 : 여러 부모 후보 중에서 해당 콘텐츠나 원 서버와 더 가까운 특정 부모
        - **프로토콜/타입 라우팅**
            - 어떤 자식 프락시는 URI에 근거하여 다른 부모나 원 서버로 라우팅 가능
        - **유료 서비스 가입자를 위한 라우팅**
            - 웹 서비스 운영자가 빠른 서비스를 위해 추가금을 지불했다면, 그들의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 가능

<br>

![2025  8  10  17:46 Microsoft Lens(1)](https://github.com/user-attachments/assets/973af3f7-1408-481e-a292-47bef664b75f)

그러나, 항상 게층적이어야 할 필요는 없다.

위 사진과 같이 부하 균형, 지리적 인접성에 근거한 라우팅, 프로토콜/타입 라우팅 등에 의해 동적으로 부모를 선택할 수도 있다.

또, 유료 서비스 가입자를 위한 경우 더 성능 개선이 잘 된 곳으로 이동하게끔 할 수 있다.

<br>

#### 어떻게 프락시가 트래픽을 처리하는가
클라이언트는 보통 웹 서버와 직접 대화하기에, 어떻게 HTTP 트래픽이 프락시로 향하는 길에 대해 잘 모른다.

클라이언트 트래픽이 프락시로 가도록 하는 방법은 네 가지가 있다.

![2025  8  10  17:52 Microsoft Lens](https://github.com/user-attachments/assets/2314aa25-4420-4183-8570-0ef617d79886)

- 클라이언트를 수정한다.
  - 많은 웹 클라이언트들은 수동, 혹은 자동 프락시 설정을 지언한다.
  - 만약 프락시를 사용하도록 설정되어 있다면, 클라이언트는 HTTP 요청을 프락시로 보낸다.
- 네트워크를 수정한다.
  - 클라이언트를 모르고 간섭도 할 수 없는 상태에서, 네트워크 인프라를 가로채서 트래픽을 프락시로 가게할 수 있다.
  - 이 가로챔은 HTTP 트래픽을 지켜보고 클라이언트도 모르게 프락시로 보내는 스위칭과 라우팅 장치가 필요하다 (= 인터셉트 프락시)
- DNS 이름공간을 수정한다.
  - 웹 서버 앞에 있는 대리 프락시는 자신이 웹 서버의 IP주소와 이름을 사용한다.
  - 그래서 모든 요청이 대리 프락시로 가는데, 이는 DNS 이름 테이블을 수동 편집을 하거나, 동적 DNS를 통해 조정될 수 있다.
- 웹 서버를 수정한다.
  - 몇몇 웹 서버는 HTTP 리다이렉션 명령으로 클라이언트에게 프락시로 요청하라고 설정할 수 있다.

##

### 클라이언트 프락시 설정
모든 현대적인 브라우저는 프락시를 사용할 수 있도록 설정할 수 있다.

- 수동 설정
- 브라우저 기본 설정
- 프락시 자동 설정 (PAC = 프락시 자동 설정)
  - 수동 설정과 달리 동적 설정이다.
  - 자바스크립트 파일이 적절한 프락시 서버를 선택해준다.
- WPAD 프락시 발견 (WPAD = 웹 프락시 자동발견 프로토콜)
  - 브라우저에게 알맞은 PAC 파일을 찾아주는 알고리즘

##

### 프락시 요청의 미묘한 특징들
#### 프락시 URI와 서버 URI는 다르다
메세지 문법은 서로 같지만, URI가 서로 다르다. 서버에 보낼때는 스킴, 호스트, 포트번호를 넣지 않지만, 프락시에 요청할 때는 모두 포함하여 보낸다.

왜 그러냐면, 옛날에는 클라이언트-서버가 직접 대화해서 가상 호스팅도, 프락시도 없었다. 그러니 서버는 자신의 호스트 명과 포트번호를 알고 있어서 스킴과 호스트를 굳이 안 보냈다.

그러나, 프락시가 나타나고 게이트웨이 등 다른 스킴과 연결하기 위해 또 URI 스킴을 알 필요가 있었다.

그래서 클라이언트가 프락시를 사용한다면, URI 스킴까지 포함한 전체를 보내고, 그렇지 않으면 서버에게 부분 URI만 보낸다.

대리 프락시는 웹 서버로 위장하기 때문에 부분 URI만 보낸다.

<br>

#### 프락시 없는 URI 분석

![2025  8  10  20:21 Microsoft Lens 2](https://github.com/user-attachments/assets/4b2fa8ce-0083-495e-9db9-9c14710eaf0d)

앞장에서 배운 URL 확장으로 www와 .com을 붙이고, DNS로부터 IP주소를 받아 커넥션을 맺는다.

<br>

#### 명시적 프락시를 사용할 때의 URI 분석

![2025  8  10  20:21 Microsoft Lens(1) 1](https://github.com/user-attachments/assets/920dcdfe-4db3-4d67-b4e0-1fab96f8c89f)

프락시를 사용하면 부분 호스트 명을 자동확장하지 않고, 프락시는 서버에 잘 요청한다.

##

### 메세지 추적
프락시가 점점 흔해지면서, 프락시를 넘나드는 메세지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

#### Via 헤더
3장에 나왔던 일반 헤더에 있는 것으로, 메세지가 지나는 각 중간 노드(프락시 or 게이트웨이)의 정보를 나열한다.

`Via: 1.1 proxy-62~.net, 1.0 cache.~.com`과 같이 문자열을 남기고, 지날 때마다 끝에 추가된다. 첫 번째 프락시는 HTTP 버전 1.1, 두 번째 프락시는 HTTP 버전 1.0을 사용하는 것을 알 수 있다.

요청과 응답 메세지 모두 프락시를 지날테니, 둘 다 Via 헤더를 가질 것이고 요청에서 A, B, C 프락시를 지났다면 응답에서는 C, B, A를 지나므로 요청과 응답의 Via 헤더는 반대이다.

Via 헤더는 프로토콜 변환을 기록하므로, HTTP 애플리케이션은 프락시 연쇄에서 프로토콜 변환이 있었는지 알아챌 수 있다.

<br>

#### TRACE 메소드
프락시 서버는 메세지가 전달될 때 메세지를 바꿀 수 있다. 헤더가 추가되거나, 변경되거나 삭제될 수 있고 본문도 다른 형식으로 변환될 수 있다.

HTTP/1.1의 TRACE 메소드는 요청 메세지를 프락시의 연쇄를 따라가면서 각 프락시가 어떻게 수정하는지 관찰/추적할 수 있다. 따라서 프락시 디버깅에 매우 유용하다. 참고로 TRACE 응답은 수신한 요청 메세지를 그대로 돌려보낸다.

TRACE 응답이 도착하면, 클라이언트는 서버가 받은 메세지와 지나친 프락시 목록을 검사할 수 있고, ContentType은 message/http이다.

Max-Forwards 헤더를 통해서 요청의 프락시 홉 개수를 제한하기 위해 사용될 수 있다.

##

### 프락시 인증
프락시는 접근 제어 장치로 제공될 수도 있는데, 프락시는 사용자가 유효한 접근 권한 자격이 없으면 407 Proxy Authorization Required 상태코드를 사용할 수 있다.

클라이언트는 자격을 획득하면 Proxy-Authorization 헤더필드에 담아서 요청을 다시 보내야 한다.

##

### 프락시 상호운용성
프락시는 모든 헤더를 다 이해못할 수도 있다. 따라서 다음 홉에 전달하려고 시도해야 하고, 또 HTTP/1.1 에서 메소드 확장을 통해 해결할 수도 있다.
