# 통합점: 게이트웨이. 터널, 릴레이

## 게이트웨이
- 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
- 리소스와 애플리케이션을 연결하는 역할(요청을 받고 응갑하는 포털?)

#### 예시 (리소스 게이트웨이)
<img width="926" height="368" alt="image" src="https://github.com/user-attachments/assets/fda72b9a-527f-40c9-93ef-a88b90bd104d" />


- 프로토콜 변환도 수행 가능 (클라이언트의 편이성)

#### HTTP로 받은 FTP URL 요청 → FTP 서버에 연결하여 적절한 명령 수행

<img width="684" height="221" alt="image" src="https://github.com/user-attachments/assets/9c9ff23f-0c9a-4d6b-8d36-ab9f129f61ff" />


#### SSL로 받은 요청 → 일반 HTTP로 변환

<img width="654" height="227" alt="image" src="https://github.com/user-attachments/assets/c1b2e029-87ab-4b1a-b6f0-ef01ef3eeb3e" />


#### HTTP 클라이언트 요청 → 서버 측 애플리케이션 프로그램

<img width="705" height="234" alt="image" src="https://github.com/user-attachments/assets/5e5871ee-064d-4fe6-8cd0-03ce8771bede" />


### 클라이언트 & 서버 측 게이트웨이
> 포맷: <클라이언트 프로토콜>/<서버 프로토콜>
- 서버 측: 클라이언트와 HTTP, 서버와는 외래 프로토콜
- 클라이언트 측: 클라이언트와 외래 프로토콜, 서버화 HTTP

## 프로토콜 게이트웨이

- 보통, 브라우저에 명시적으로 게이트웨이 설정 가능
	- 자연스럽게 트래픽이 게이트웨이로 or 게이트웨이를 대리 서버로 설정

#### HTTP/FTP 동작 화면

<img width="935" height="453" alt="image" src="https://github.com/user-attachments/assets/a61d1746-5517-47b3-9b26-63955e0913ee" />


- HTTP/*: 서버 측 웹 게이트웨이
	- 원 서버 영역으로 들어오는 클라이언트 측 HTTP 요청을 외래 프로토콜로 전환

<img width="930" height="374" alt="image" src="https://github.com/user-attachments/assets/a5d073a4-1336-4669-9502-beff0100eaf1" />


- HTTP/HTTPS: 서버 측 보안 게이트웨이
	- 기업 내부의 모든 웹 요청을 자동으로 암호화

<img width="919" height="283" alt="image" src="https://github.com/user-attachments/assets/74669c4e-16d9-4811-bbb2-f73fae492908" />


- HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이
	- 주로 인터셉트 게이트웨이나 리버스 프락시 역할
	- 보안 HTTPS 트래픽 복화루 웹서버로 보낼 일반 HTTP 요청 생성

<img width="933" height="338" alt="image" src="https://github.com/user-attachments/assets/df7a1313-1876-4c14-a28e-7abf8fcb6dd9" />

> 단 내부 커넥션의 보안에 신경써야 한다

## 리소스 게이트웨이
- 애플리케이션 서버: 목적지 서버 + 게이트웨이
	- *게이트웨이의 가장 일반적 형태*
	- HTTP를 통해 클리이언트와 통신 **&** 서버 측 애플리케이션 프로그램에 연결

#### 예시

<img width="934" height="466" alt="image" src="https://github.com/user-attachments/assets/6e57873a-77e2-4bf0-a0b7-58d370a63dbd" />


- A: 요청 URI에 따라서 API를 통해 디지털카메라 애플리케이션에 요청이 전송. HTTP응답 메시지는 최종 카메라 이미지를 감싸도 클라이언트에 전송.
- B: 서버 게이트웨이 API를 통해 전자상거래 소프트웨어로 전송, 뒤 결과는 브라우저로 전송.

### 서버 게이트웨이 애플리케이션의 동작 / CGI 모델의 기본 체계

<img width="934" height="387" alt="image" src="https://github.com/user-attachments/assets/59a53105-e2a2-473d-a5d5-d86d71ff7224" />


- 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 핼퍼 애플리케이션을 생성하여 요청을 처리.
- 요청 처리 후 바로 클라이언트로 전달할 응답 / 응답 데이터를 서버에 반환.

## 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)

- 유명했던 최초의 API/서버 확장
- 게이트웨이의 인터페이스를 수현하는 단순한 접근 방식이 오늘까지 이어짐 (아직 널리 쓰여짐)
- 거의 모든 HTTP 서버가 지원
- 특정 URI에 대한 HTTP 요청에 따라 프로그램 실행, 출력 수집, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합.
- 거의 모든 리소스 형식과 서버의 접점에 있으며, 필요에 따른 어떤 변형이든 처리
- 문제 많은 확장으로 서버 보호

## BUT

- 성능 떠러트임 (모든 CGI 요청이 새로운 프로세스)
- 서버 장비 부담

> 이는 데몬으로 동작하는 Fast CGI로 어느정도 해결 가능. 

## 서버 확장 API
- 한계가 명확한 CGI 프로토콜의 대처품
	- 서버 성능을 쥐어짜낼수 있음
	- 서버 동작 수정 가능
- 웹 개발자가 서버 개발자의 모듈에 직접 HTTP로 연결할수 있게 해준.

> 서버 자체 아키텍처에 의존함으로, 한 가지 서버에 대부분 특화되있다. (NetScape, Microsoft, Apache, etc)

## 애플리케이션 인터페이스와 웹 서비스
- 애플리케이션이 상호 운용을 하다보면 HTTP 헤더로는 표현하기 힘든 정보를 교황해야 할 수도 있다.
- 인터넷 커무니티는, 애플리케이션이 서로 통신할 표준과 프로토콜 집합 개발. *웹 서비스*
	- SOAP(Simple Object Acess Protocol)을 통해 XML 정보 교환.

## 터널
- HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공.
	- HTTP 커넥션을 통해서 HTTP가 아닌 무언가를 전송. (Wrapper 개념)

### CONNECT로 HTTP 터널 커넥션 맺기
- CONNECT: 웹 터널이 HTTP를 사용하여 커넥션을 맺을떄 쓰는 메서드. (1.1 명세에 자세히 나와있지는 않으나, 많이 구현됨)

- CONNECT 요청: 호스트 명이 대신하며 콜론에 이어 포트 기술
`CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0
`

- CONNECT 응답: 일반 메시지와 같이 200 응답.
` HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
'
> Content-type 헤더는 필요 없다.

#### 예시) SSL 터널을 연결하기 위해 사용되는 CONNECT

<img width="928" height="808" alt="image" src="https://github.com/user-attachments/assets/30a6c799-6949-4224-9c5e-a6cee353ed75" />


> 다른 거는 아나, 비슷하다.

## 데이터 터널링, 시간, 커넥션 관리
- 게이트웨이는 터널을 통해 전달되는 정보를 볼수 없다. 
- 패킷의 순서나 흐름에 대 한 어떤 가정도 할 수 없다.
- 클라이언트는 성능을 높이기 위해 CONNECT 요청 다음에 바로 터널 데이터를 전송할 수 있다.
	- 게이트웨이는 커넥션이 맺어지는 대로, 읽어드린 모든 데이터를 서버에 전송해야 함
	- 클라이언트가 에러 담당을 해야함
- 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 남은 데이터 전송을 처리하고, 전송이 안된 데이터는 버린다.

### SSL 터널링
- 터널링이 개발된 이유: SSL 트래픽
<img width="935" height="613" alt="image" src="https://github.com/user-attachments/assets/022f4c08-841d-457b-9d05-800e8086780e" />


- 암호화된 데이터 HTTP사용 전송 예시
<img width="934" height="688" alt="image" src="https://github.com/user-attachments/assets/132a0528-2115-4095-9cb0-a2426f3ceeb0" />


a) 보안 웹 서버로 바로 전송

b) 일반 SSL 커넥션을 통해 전송되기 전까지 HTTP 메시지에 담겨, HTTP 포트 80에 전송

### SSL 터널링 vs HTTP/HTTPS 게이트웨이
- 보안 (outbound == 보안 X)
- 게이트웨이의 SSL 완벽 지원
- 원격 서버에 SSL 클라이언트 인증

### 터널 인증
- 프락시 인증 기능은, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널을 사용
<img width="459" height="434" alt="image" src="https://github.com/user-attachments/assets/951e9bec-857b-4c15-a724-afae6afeb6bb" />


### 터널 보안에 대한 고려사항들
- 터널의 오용을 최소화하기 위해서, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링 할 수 있게 허용.

## 릴레이
- HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프락시
- HTTP 통신을 한 다음, 바이트를 맹복적으로 전달.
 
