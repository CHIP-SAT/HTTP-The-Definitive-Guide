## HTTP/2.0 등장 배경
HTTP/1.1은 단순성과 접근성에 주안점을 두고 최적화되어, 성능을 어느정도 희생시킴.

**예:** 커넥션 하난를 통해 요청 하나를 보내고, 그에 대한 응답 하나만을 받는 HTTP 메시지 교환 방식에서 일어나는 심각한 지연을 근본적으로 피할 수 없음.

이를 해결하고자 병렬 커넥션이나, 파이프라인 커넥션을 도입. 그러나 이는 근본적인 해결책은 되지 못함. 

2009년에 구글이 발표한 SPDY 프로토콜이 등장.
이는 헤더 압축 밑 하나의 TCP 커넥션에 여러 요청을 동시에 보낼수 있게 함. 추가적으로 서버가 클라이언트와 상관없이 서버가 능동적으로 리소스를 푸시하는 기능도 장착.

이후 SPDY 프로토콜은 HTTP/2.0 프로토콜 설계의 기반이 됨.

## HTTP/2.0 개요
- 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작. 이때 TCP 커넥션을 초기화하는 것은 클라이언트.

<img width="876" height="486" alt="image" src="https://github.com/user-attachments/assets/bdfa9bc0-b318-46f1-b6ce-537ce6bc1d01" />

- 한 커넥션 위의 여러 스트림
	- 요청과 응답은 길이가 정의된 한 개 이상의 '프레임'에 담긴다. 
	- 한 개의 스트림은 한 쌍의 요청과 응답을 처리. 이는 하나의 커넥션 위에 여러 개 존재할수 있음.
	- 스트림에 대한 흐름 제어와 우선순위 시능도 제공.
- 서버 푸시
	- 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 요청을 안 받고도 능동적으로 응답을 보내줄수 있는 기능.
- 기존 웹 애플리케이션들과 호환성을 최대로 유지하기 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지함.
	**예시**
  	|HTTP/1.1|HTTP/2.0|
  	| --- | --- |
  	| Content-Length | :content-length |
  	| 404 Not Found | :status = 404 |

## HTTP/1.1과의 차이점

### 프레임 
<img width="1019" height="401" alt="image" src="https://github.com/user-attachments/assets/f0cce752-4bfb-4728-a50f-f26820727ef0" />

HTTP/2.0의 모든 메세지는 프레임이 담겨 전송.
프레임의 시작은 8바이트 이며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.
- `R(2)`: 예약된 2비트 필드. 반드시 0 이어야 함. 또한 받는 쪽은 이 값을 무시.
- `길이`: **페이로드**의 길이를 나타네는 14비트 무부호 정수.
- `종류`: 프레임의 종류 (8비트)
- `플래그`: 프레임의 종류에 따라 프래그 값은 의미가 다르다. (8비트)
- `R(1)`: 예약된 1 비트 필드. R(2)과 같은 역할.
- `스트림 식별자`: 31비트 스트림 식별자로, 0은 커넥션 전체와 연관됨을 의미함

### 스트림과 멀티플렉싱
스트림은 프레임의 독립된 양방향 시퀀스이고, 한 커넥션 안에 여러 개의 스트림이 존재한다.

한 쌍의 HTTP 요청과 응답은 하나의 스트림으로 이루어진다. 요청 받은 서버는 그 요청과 같은 스트림으로 응답을 보내고, 스트림을 닫는다.

HTTP/1.1에서는 요청을 보냈을 때, 응답이 도착해야, 그 커넥션에 다시 요청을 보낼 수 있다. 그로 인해, 커넥션을 여러 개 만들어 동시에 여러 개의 요청을 보내려 한다. 
그러나 이도 한계가 명확하며, 결국에는 지연을 마주하게 된다.

그러나 HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림을 동시에 열 수 있다.

추가적으로 스트림은 우선순위도 가질 수 있다. 즉, 상황에 때라 리소스의 중요도를 파악해서 스트림의 우선순위를 결정할수 있다.

이런 스트림을 구별하기 위해 각자 고유한 식별자가 있는데, 한 커넥션에서 한 번 사용한 식별자는 다시 사용할 수 없다. 즉, 고갈되면 다시 커넥션을 맺어야 한다.

`WINDOW_UPDATE`프레임을 이용한 흐름 제어로, 스트림들이 서러 간섭해서 만가지는 섯을 방지한다.

## 헤더 압축
HTTP/1.1에서 헤더는 압축없이 그대로 전송됨.

요청의 양이 늘어나면서, 헤더의 크기가 지연과 대역폭 양쪽에 영향을 끼치게 되었고, SPDY에서는 압축을 통해 해결했다.

HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송 >> 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원

**HPACK은 헤더를 압축하고 해제할 때 압축 콘텍스트를 사용하기 때문에 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야 함**

## 서버 푸시
HTTP/2.0은 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있다.

클라이언트가 어떤 리소스를 요구할 지 미리 알 수 있을 때 유용한데, 이를 통해서 클라이언트가 요청하기 전에 보내므로 트래픽과 회전 지연을 줄여준다. (index.html을 요청하면 .css, .js, .jpg등을 같이 보내주는거)

리소스를 푸시하려는 서버는 `PUSH_PROMISE` 프레임을 보내어 미리 알려주어야 하고, 클라이언트는 이를 받으면 해당 프레임의 스트림은 '예약됨' 상태가 된다.

  - 이 상태에서 클라이언트는 `RST_STREAM` 프레임을 보내어, 푸시를 거절할 수 있음. (스트림을 즉각으로 닫힘)
	- 닫히기 전까지 클라이언트는 서버가 푸시하여는 리소스를 요청해서는 안된다. (중복 요청을 막기 위함)

### 주의할 점
- 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않거나, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수도 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관 있어야 함. 
- 서버가 보내는 `PUSH_PROMISE` 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 한다. (example.org != www.example.org)
- 서버 푸시를 끄고 싶으면 SETTINGS_ENABLE_PUSH을 0으로 설정

## 알려진 보안 이슈
### 중개자 캡슐화 공격(intermediary Encapsulation Attacks)
프락시가 HTTP/2.0 메시지를 1.1 메시지로 변환할때, 의미가 변도될 가능성이 있음. 

2.0은 바이너리 인코딩을 사용하므로, 어느 문자열을 사용할수 있다. 

그러나 이는 정상 HTTP/2.0 메시지가, 위조된 HTTP/1.1 메시지로 번역되는것을 유발할 수 있다. (특히 예약된 문자열을 사용할시에 발생 가능)
