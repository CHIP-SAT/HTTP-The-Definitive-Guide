# 6장 - 프락시

## 개요
- HTTP 프락시와 웹 게이트웨이를 비교하고, 배치 방법 보기
- 몇 가지 활용법
- 실제 네트워에 어떻게 배치되어 었는지와 트래픽이 어떻게 프락시 서버로 가게 되는지 설명
- 브라우저가 프락시를 사용하려면 어떻게 설정되어야 하는지 보여주기
- 프락시 요청과 서버 요청의 차이, 그리고 프락시가 어떻게 브라우저의 동작을 미묘하게 바꾸는 방법을 설명
- 메시지의 경로를, Via 헤더와 TRACE 메서드를 이용해 기록하는 방법
- 프락시 기반, HTTP 접근 제어
- 클라이언트와 서버사이에서 어떻게 다른 기능과 버전 들을 지원하면서 상호작용 할 수 있는지 설명

## 6.1 웹 중개자
- 필수는 아니지만, 존재할때 클라이언트와 웹 서버 사이의 중개자 역할을 수행.
- 서버와 클라이언트의 역할과 규칙을 동시에 가진다.

## 6.2 개인 프락시와 공유 프락시

- 공용 프릭시

    프락시의 대다수. 
    관리하는 게 더 비용효율이 높고 쉽다. 
    캐시 서버와 같은 몇몇 프락시 애플리케이션은 여러 사람들이 공통된 요청에서 이득을 취할수 있다. (사용자가 많으면 좋음)

- 개인 프락시

    흔하지는 않지만 꾸준히 사용됨.
    브라우저 보조 제품 기능 확장, 성능 개선, 무료 ISP 서비스를 위한 광고 목적으로 사용자 컴퓨터에 작은 프락시는 직접 실행.

### 6.1.2 프락시 vs. 게이트웨이 
- 프락시

	**같은** 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결. (전달사)

- 게이트웨이

	**서로 다른** 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결. (번역가)

EXAMPLE

<img width="941" height="475" alt="스크린샷 2025-08-07 145432" src="https://github.com/user-attachments/assets/2b515ac6-d8fe-4117-a8a1-d243f0751513" />


실질적으로 프락시와 게이트웨이의 차이점은 모호하다.
1) HTTP 버전 차이로 인한 프록시가 약간의 프로토콜 변환함.
2) 상용 프락시 서버가 많은 웹 기반 애플리케이션을(SSL, SOCKS Firewall, FTP access 등) 지원하기 위해 게이트웨이 기능을 구현.

## 6.2 왜 프락시를 사용하는가?
> 모든 HTTP 트래픽을 보고, 건들수 있다. 

실용적이고 유용한 것이라면 구현 가능. (보안 개선, 성능 향상, 필터 등)

|예시|설명|
| --- | --- |
| 어린이 필터 | 어린이에게 부적절한 사이트 접근 강제 거절 |
| 문서 접근 제어자 | 수많은 웹 서버들과 리소스에 대한 단일한 접근 제어 구현, 감사 추적 등. (수많은 웹 서버들의 접근 제어 갱신 없이, 중앙 프락시 서버에서 접근 제어) |
| 보안 방화벽 | 응용 레벨 프로토콜의 흐름을 네트워크 한 지점에서 통제. 트레픽을 게김히 살펴볼 수 있는 후크(hook) 제공.
| 웹 캐시 | 인기 있는 문서의 로컬 사본을 관리하고, 해당 문서에 대한 요청에 빠른 응답을 제공. |
| 대리 프락시(surrogate) | 웹 서버인 것처럼 위장하며, 서버들의 대리인 역할을 한다. 클라이언트에게 프락시 자체가 본 웹 서버인것처럼 보이게 한다. |
| 콘텐츠 라우터 | 인터넷 트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹 서버로 유도한다. |
| 트랜그코더 | 클라이언트에게 전달하기 위해 본문 폼맷을 수정한다. |
| 익명화 프락시 | HTTP 메시지의 신원을 식별할수 있는 특성들을 적극적으로 제거한다. |

## 6.3 프락시는 어디에 있는가?
- 어떻게 배치되는가
- 어떻게 연쇄가 계층을 이루는가
- 어떻게 트래픽이 올바르게 프락시를 찾아가는가

### 6.3.1 프락시 서버 배치

<img width="654" height="194" alt="스크린샷 2025-08-07 153349" src="https://github.com/user-attachments/assets/e7f9ee84-6d63-48b1-b420-eeb26cdbbbe3" />


- **출구(Egress) 프락시**

    로컬 네트워크와 인터넷 사이에 오가는 트래픽을 제어하기 위해 네트워크 출구에 박아 넣은 프락시.
**방화벽, 인터넷 요금 절약, 트래픽 성능 개선, 어린이 필터 등**

<img width="908" height="255" alt="스크린샷 2025-08-07 154918" src="https://github.com/user-attachments/assets/2a7782ae-51f8-4d2a-a14d-d25db08afaa0" />


- **접근(입구) 프락시**

    고객의 모든 요청을 종합적으로 처리하기 위해 ISP 접근 지점에 쥐치한 프락시.
**다운로드 속도 개선, 캐시 프락시 사용**

<img width="898" height="251" alt="스크린샷 2025-08-07 154944" src="https://github.com/user-attachments/assets/2d7fcaba-8b8e-4142-a95c-b27ac16dc602" />


- **대리 프락시**

    웹 서버들의 바로 앞에 위치하여, 웹 서버로 향하는 모든 서버 요청을 처리하고 필요할 때만 웹 서버에게 지원을 요청할 수 있다.
    ** 웹 서버 통합, 성능 개선 등**

<img width="906" height="273" alt="스크린샷 2025-08-07 155002" src="https://github.com/user-attachments/assets/f40b598c-60b4-49f4-a3a1-d0a520e3f373" />


- **네트워크 교환 프락시**

    인터넷 피어링 지점에 설치되어 캐시를 이용해 인터넷 교차로의 혼잡 완화, 트래픽 감시등을 위해 충분한 처리 능력을 갖춘 프락시.

### 6.3.2 프락시 계층

<img width="915" height="253" alt="스크린샷 2025-08-07 162946" src="https://github.com/user-attachments/assets/79c79c55-bc30-4e4c-b9b0-b031a3640fa0" />


> 정적 프락시 계층

- **프랏시 계층 콘텐츠 라우팅**

    프락시 서버는 위의 사진처럼 정적이 아니라, 여러 가지 판단 근거에 의해 메시지를 다양하고 유동적인 프락시 서버와 원 서버들의 집합에게 보낼 수 있다.



**동적 부모 선택의 몇 가지 예**
|예시|설명|
| --- | --- |
| 부하 균형 | 자식 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고른다 | 
| 지리적 인접성에 근거한 라우팅 | 자식 프락시는 원 서버의 지역을 당당하는 부모를 선택할 수도 있다. |
| 프로토콜/타입 라우팅 | URI에 근거하여 다른 부모나 원 서버로 라우팅 할 수 있다. (특수 프로토콜 처리용 등) |
| 유로 서비스 가입자를 위한 라우팅 | 웹서비스 운영자가 빠른 서비스를 위해 추가금을 지불했다면, 그들의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 될 수 있다. (위의 예시 확장 버전?) |

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

클라이언트 트래픽이 프락시로 가도록 하는 네 가지 방법:
1) **클라이언트를 수정한다**

    많은 웹 클라이언트들은 수동 혹은 자동 프락시 설정을 지원한다. (HTTP 요청응 의도적으로 프락시로 보낸다)

<img width="467" height="283" alt="스크린샷 2025-08-07 163503" src="https://github.com/user-attachments/assets/85479e28-2cba-4e38-bad7-0b735187bf33" />


2) **네트워크를 수정한다**

    스위칭 장치와 라우팅 장치등을 써서 네트워크 인프라를 가로채서, 웹 트래픽을 프락시로 가도록 조정할수 있다. (Also known as Intercepting Proxy)

<img width="440" height="282" alt="스크린샷 2025-08-07 163522" src="https://github.com/user-attachments/assets/a01c669f-fd7f-4c31-8783-3a26ba3df33c" />


3) **DNS 이름공간을 수정한다**

    웹 서버의 이름과 IP주소를 자신처럼 사용하는 직접 사용하는 대리 프락시는, DNS 이름 테이블을 수동으로 편집하거나, 특별한 동적 DNS 서버를 이용해서 조정할수 있다.

<img width="471" height="283" alt="스크린샷 2025-08-07 163904" src="https://github.com/user-attachments/assets/9a3dca6e-ed9f-49a5-bd0e-3d6dd2aec2e1" />


4) **웹 서버를 수정한다**

    몇몇 웹 서버는 HTTP 리다이렉션 명령(응답 코드 305)을 사용하여 클리이언트의 요청을 프락시로 리다이렉트 하도록 설정할 수 있다.

<img width="442" height="297" alt="스크린샷 2025-08-07 164141" src="https://github.com/user-attachments/assets/6d6a3a3e-7232-498c-9e1a-107bfef4d523" />


## 6.4 클라이언트 프락시 설정

|클라이언트 프락시 설정|설명|
| --- | --- |
| 수동 설정 | 프락시 사용하겠다고 명시적으로 설정 |
| 브라우저 기본 설정 | 브라우저 벤더나 베포자는 프락시 사용을 미리 설정해 놓을 수 있다 |
| 프락시 자동 설정(Proxy auto-configuration, PAC) | 그때그때 상황에 맞게 계산해 프락시 설정을 바꿔주는 이 작은 자바스크립트 프로그램은 프락시 수동 설정에 대한 보다 동적인 해결책이다. |
| WPAD(Web Proxy Autodiscovery Protocol) 프락시 발견 | 대부분의 브라우저는 자동설정 파일을 다운받을 수 있는 '설정 서버'를 자동으로 찾아주는 프로토콜 (브라우저에 알맞는 PAC 파일을 자동으로 찾아주는 알고리즘) |

PAC 예시:

<img width="917" height="343" alt="스크린샷 2025-08-07 170616" src="https://github.com/user-attachments/assets/12d2117e-94c8-4132-87ba-a167631cbb0c" />


현재 WPAD 리소스 발견 기법 명세:

- 동적 호스트 발견 규약(DHCP)
- 서비스, 위치 규얏(SLP)
- DNS 잘 알려진 호스트 명
- DNS SRV 에코드
- DNS TXT 레코드 안의 서비스 URI

## 6.5 프락시 요청의 미묘한 특징들
> Because apparantly, this absolute rabbit-hole can get deeper. ISTG this hurts my head.


### 6.5.1 프락시 URI는 서버 URI와 다르다
웹 서버로 요청에는 스킴, 호스트, 포트번호가 없는 부분 URI를 자긴다.
그 반면, 프락시를 사용한 요청에는 완전한 URI를 갖어야 한다.

Why?

원래 HTTP 설계에는 단일 서버만 고려하여 만들었기 때문에, 클라이언트는 불필요한 정보 전송을 피하기 위해 부분 URI만 사용했다.

그러나 프락시는 목적지 서버와 커넥션을 맺어야 했기 떄문에, 완전한 URI를 사용해야 한다.

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

한 웹 서버에 여러 웹 사이트가 호스팅 되는대 부분 URI가 오면 누구의 리소스를 지정해야 할지 난감해진다.
**Host 헤더 요구**

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다
인터셉트 프락시는 클라이언트에서 서버로 가는 트래픽을 가로채기 때문에, 웹 서버로 보내는 부분 URI를 얻는다.

### 6.5.4 프락시는 프릭사 요청과 서버 요청을 모두 다룰 수 있다
다목적 프락시 서버는 완전한 URI, 부분 URI, 그리고 웹 요청의 경우에는 가상 Host 헤더를 사용해야 한다.

완전/부분 URI 사용 규칙:
- 완전한 URI >> 프락시는 주어진 URI 사용
- 부분 URI & Host 헤더 >> Host 헤더를 사용한 서버 이름과 포트 번호 찾기
- 부분 URI *BUT* Host 헤더 **X** >> 다음 방식 사용
  1) 대리 프락시 >> 실제 서버 주소 & 포트 번호 설정 되었을 수도
  2) 이전 인터셉트 프락시가 원 IP 주소&포트 사용 OK? >> 그 IP 주소&포트 번호 사용
  3) 모두 실패 >> 반드시 에러 메시지 반환

### 6.5.5 전송 중 URI 변경
프락시 서버는 요청 URI의 변경에 매우 신경을 써야 한다. 이는 다운스트림 서버와 상호운용성 문제를 고려해서 그렇다.

일반적으로 프락시 서버는 관대하도록 애써야 한다.
특히나 일번적인 인터셉트 프락시가 빈 경로를 '/'로 교체하는것을 제외하면, 절대 경로를 고쳐 쓰는것을 금지한다.

### 6.5.6 URI 클라리언트 자동확장과 호스트 명 분석(Hostname Resolution)
브라우저는 입력한 URI의 호스트가 발견되지 않으면,  호스트 명의 '확장'을 제공하고자 한다.

1) 접두사, 접미사, 자동 생성
2) 제 3자 사이트로 넘겨, 오타 교정 시도
3) 대부분 DNS는 사용자가 호스트 명의 앞부분만 입력하면, 자동으로 도메인을 검색

### 6.5.7 프락시 없는 URI 분석(URI Resolution)
아래의 그림을 참고하시오.
뭐라 설명이 좀...

<img width="921" height="433" alt="스크린샷 2025-08-07 185507" src="https://github.com/user-attachments/assets/402a7829-087c-4d66-b078-d4c909ac6f45" />


### 6.5.8 명시적인 프락시를 사용할 떄의 URI 분석
이것고 아래의 그림을 참고.
(프락시가 특정 키워드에 인식되있는 상태)

<img width="917" height="506" alt="스크린샷 2025-08-07 185810" src="https://github.com/user-attachments/assets/c2299b14-b221-44bc-9816-d86ab3b88912" />


### 6.5.9 인터셉트 프락시를 이용한 URI 분석
*호스트명 자동확장까지는 별 차이가 나지 않지만 서버로의 커넥션이 만들어졌을 때 분명한 차이가 난다.*

1) 클라이언트는 주로 원 서버와 커넥션이 성공할때까지 계속 연결을 시도한다. 

2) 그러나 인터셉트 프락시는 이 시도를 첫번쨰 연결에 가로채어 종료시킨다.

3) 그러나 클라이언트는 이를 모르고, 성공적으로 연결했다고 믿는다.
요기서의 문제는, 연결하려는 웹 서버가 살아있지 않을수 있다는 것이다.

4) 프락시도 곧 이를 인식하게 되는데, 브라우저에서 제공하는 것과 동등한 장애 허용을 제공하기 위하여, 호스트 헤더 분석, 리버스 DNS 룩업을 해서든 IP 주소를 시도한다.

> 브라우저가 명시적인 프락시를 사용하도록 설정되어 있는 경우에, 장애 허용은 프락시에 달려있기 떄문에, 명시적/인터셉트 프락시는 죽은 서버에 대한 장애 허용을 지원해야 한다.

## 6.6 메시지 추적

프락시가 점점 더 흔해지면서, 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

### 6.6.1 Via 헤더
메서드를 가지고 있는 메시지가, 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록 끝에 반드시 추가되어진다.
이는 메시지 전달 추적, 메시지 루프 진단, 요청과 응답 과정에서 모든 메시지 발송자의 프로토콜을 다루는 능력을 알아보기 위해 사용.

- **Via 문법**
1) 경유지 프로토콜 이름(HTTP라면 선택적, 아니라면, 버전 앞에 '/'로 구분되어 쓰여짐)
2) 프로토콜 버전 **(필수)**
3) 노드 이름 **(필수)**
4) 코멘트(선택, 노드에 대한 추가적 설명)

- **Via 요청과 응답 경로**

    요청과 응답 메시지는 보통 같은 TCP 커넥션을 오가므로, 응답 메시지는 요청과 같은 경로를 되돌아간다.

- **Via와 게이트웨이**

    Via 헤더는 프로토콜 변환을 기록하여 HTTP 애플리케이션이 프록시 체인 전체에서 프로토콜 기능 및 변환을 인식할 수 있도록 합니다.

- **Server 헤더와 Via 헤더**

    Server 응답 헤더: 원 서버에 의해 사용되는 소프트웨어 내용.
    프락시가 응답 메시지에 대한 활동: 서버 헤더는 수정 **X**, Via 항목 추가 **O**.

- **Via가 개인정보 보호와 보안에 미치는 영향**

    일반적으로, Via 문자열에 정확한 호스트 이름을 포함하지 않으려는 경우, 각 상황에 따라 다음과 같이 처리해야 합니다:
    1) 프록시가 네트워크 방화벽의 일부인 경우: 방화벽 뒤의 이름과 호스트를 전달하지 마십시오.  
    
    2) Via 노드 이름 전달이 활성화되지 않았고 프록시가 보안 경계의 일부인 경우: Via 경유점 항목을 유지하려고 시도하지만, 호스트 이름을 적절한 가명(pseudonym)으로 대체하십시오.
    3) 내부 구조를 숨기기 위한 매우 강력한 개인정보 보호: 동일한 조직적 통제 하에 있는 Via 경유점의 순차적 시퀀스를 단일 결합된 항목으로 결합합니다. (수신 프로토콜 값이 다른 항목을 결합하지 마십시오)  

### 6.6.2 TRACE 메서드
서버는 TRACE 요청의 메시지가 도착하였을때, 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함기켜 그대로 돌려보낸다.

응답의 Content-Type은 message/http이며 상태는 200 OK 이다.

- Max-Forwards
    일반적으로 TRACE 메시지는 서버로 가는 모든 가능한 경로를 통해 전송됩니다.  
    그러나 ‘Max-Forwards’ 헤더를 사용하면 프락시 '호프'의 수를 제한할 수 있습니다.  

**규칙**  
1) ‘Max-Forwards’ 헤더에는 정수 값이 지정됩니다.

2) 메시지가 전달될 때마다 Max-Forwards 필드에 값이 1 감소된 업데이트된 값이 포함되어야 합니다.  
3) 값이 0에 도달하면 메시지가 클라이언트로 반환됩니다.  

이 기능은 체인 중간에 위치한 특정 프락시 서버의 영향을 확인하는 데 유용하며, 무한 루프에서 메시지를 전송하는 프락시를 탐지하는 데도 사용됩니다.  

> 모든 프락시와 게이트웨이는 이 기능을 지원해야 한다.

## 6.7 프락시 인증
프락시를 사용한 접근 제어 장치.

메커니즘 예시:
1) 제한된 콘텐츠 요청  
2) 프락시 서버는 접근 자격 요구하는 407 Proxy Authorization Required 상태 코드와 자격 제출 방법을 설명한는 Proxy-Authenticate 헤더 필드 반환
3) 407 응답 수신 >> 로컬 데이터베이스 or 사용자에게 물어봐서 요구되는 자격 수집
4) 자격 회득? >> 요두되는 자격을 Proxy-Authorization  헤더 필드에 담아서 요청을 다시 보낸다
5) 
    |자격|반응|
    | --- | --- |
    | 자격 유효 **O** | 프락시는 원 요청을 연쇄를 따라 통과 |
    | 자격 유호 **X** | 407 응답을 보낸다 |

**NOTE:** 프락시 인증에 참여하는 프락시가 프락시 연괘상에 여러 개 있을 때는 일반적으로 잘 동작하지 않는다.

<img width="931" height="824" alt="스크린샷 2025-08-08 112001" src="https://github.com/user-attachments/assets/bdd53089-c96b-42c8-b567-e5e3b1718fc8" />


## 6.8 프락시 상호운용성
프락시의 제작사가 많은것처럼, 버그도 많다.

잘못하면, 프락시는 트롤이 될수 있다.

### 6.8.1 지원하지 않는 헤더와 메서드 다루기
프락시는 이해할수 없는 헤더를 상대적 순서를 유지한 상태에서 수정하지 않고 전달해야 한다.

비슷하게, 친숙하지 않은 메서드를 받는다면, 그 메시지를 다음 홉으로 전달하려 시도한다.

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기
HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해준다.

- 서버 전체의 능력에 대한 질문: OPTIONS * *protocol version*
- 특정 URI에 대한 능력들: OPTIONS *URI Protocol version*

성공하게 된다면, 선택적 기능을 설명하는 헤더 필드를 포함한 200 OK 응답을 반환한다.

### 6.8.3 Allow 헤더
Allow 엔터티 헤더 필드는, 요청 URI에 의해 식별되는 자원에 대해 지원하는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다.

**EXAMPLE**

Allow" GET, HEAD, PUT

Allow 헤더는 새로운 리소스가 지원해야 할 메서드를 추천하기 위해 요청 헤더로 사용할 수 있습니다.

서버는 이러한 메서드를 지원할 의무가 없으며, 일치하는 응답에 Allow 헤더를 포함하여 실제로 지원되는 메서드를 나열해야 합니다.
