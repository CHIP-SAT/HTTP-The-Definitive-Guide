## 7.1 불필요한 데이터 전송

- 같은 데이터를 여러번 이동할때 생기는 불피료한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다.
- 캐시를 사용하면 첫 번째 서버 응답이 보관되며, 뒤이은 요청들에 대한 응답으로 캐시된 사본을 사용. → 중복 트래픽 감속.

---

## 7.2 대역폭 병목
- 클라이언트의 서버 접근 속도 == 클라이언트 ~ 서버 경로의 가장 느린 네트워크 속도.
- 로컬(캐시)의 대역복 > 원격(서버)의 대역폭
- 큰 문서는 대역폭에 민감.
> 네트워크 속도는 네트워크 종류에 따라 달라진다는것을 참고.

---

## 7.4 거리로 인한 지연

- 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있음.
- 라우터로 인한 인터넷 트래픽 지연은 크지 않더라도, 물리적인 거리는 빛의 속도 한계로 인해 유의미한 지연을 발생시킨다.
- TLDR; 먼거리 + 페이지의 복잡함 = 페이지 로딩 지연

<img width="930" height="775" alt="image" src="https://github.com/user-attachments/assets/b634e4ae-2d6e-4d1a-866b-5ff197673531" />


---

## 7.5 적중과 부적중

- 캐시는 모든 사본 저장 **X**
- **캐시 적중(cache hit)**
	- 요청에 대응하는 사본이 있는 경우
- **캐시 부적중(cache miss)**
	- 대응 사본 **X** → 원 서버로 요청 전달
- **재검사(Revalidation)**
	- 캐시는 반드시 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검.
- 캐시는 언제든지 사본 재검사 가능.
	- BUT 대욕폭 부족으로, 요청된 사본이 충분리 오래된 경우에만 재검사 한다.
- **순수 캐시 적중 속도 > 재검사 적중 속도 > 캐시 부적중**
	- 순수 적중: 바로 응답
	- 재검사 적중: 신선도 확인으로 인한 작은 지연
	- 부적중: 원 서버로서 객체 데이터를 받는 이유로, 큰 지연
- 가장 흔한 재검사 도구: `If-Modified-Since' 헤더
	- GET 요청에 추가하면, 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 요청 완성.
- 위의 요청 도착 이후의 세 가지 상황:
	1. 콘텐츠 변경 **X** (재검사 적중(느린 적중))
		- 클라이언트에게 작은 HTTP `304 Not Modified` 응답을 보냄.
    <img width="931" height="419" alt="image" src="https://github.com/user-attachments/assets/4fae584f-8b33-4805-bac5-6f81a2404090" />

	2. 콘텐츠 변경 **O**(재검사 부적중)
		- 콘텐츠 전체와 함께 `HTTP 200 OK` 응답을 클라이언트로 보냄.
	3. 콘텐츠 삭제(객체 삭제)
		- 서버는 `404 Not Found` 응답을 클라이언트로 보냄.
		- 캐시는 사본을 삭제.
- 캐시 적중률(문서 적중률)
	- 캐시가 요청을 처리하는 비율
		- 0% ⇒ 모든 요청이 캐시 부적중
		- 100% ⇒ 모든 요청이 캐시 적중
- 적중률애 영향을 주는 요인
	- **캐시의 크기**
	- **사용자들의 관심사 유사성**
	- **데이터 신선도 기간 / 개인화 빈도**
	- **캐시 설정 방식**
- 바이트 적중률
	- 캐시를 통해 제공된 모든 바이트의 비율.
	- 트래픽 절감 정도 포착에 유용
		- 0% ⇒ 모든 바이트가 인터넷에서 왔다. (캐시 사용 **X**)
		- 100% ⇒ 모든 바이트가 캐시에서 왔다. (인터넷 트래픽 **X**)
- 캐시 성능 확인 역할
	- 캐시 적중률: 얼마나 많은 트랜잭션이 외부로 내보내지지 않았는지 보여줌
		- **개선?** 지연 감속
	- 바이트 단위 적중률: 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌.
		- **개선?** 대역폭 절약
- HTTP는 응답이 캐시에서 왔는지, 원서버에서 왔는지 말해줄 방법을 제공하지 않음.
	- 클라이언트가 구별하는 방법:
		1) Date 헤더: 응답의 Date 헤더 값과 현재 시각을 비교하여 구별
		2) Age 헤더: 응답이 얼마나 오래됬는지 알려주는 헤더
		3) Via 헤더: 캐시가 이곳에 추가 정보를 넣었을 때 감지(추천 **X**)

---

## 7.6 캐시 토폴로지

- **개인 전용 캐시(private cache)**
	- 개인만을 위한 작은 캐시

  <img width="776" height="188" alt="image" src="https://github.com/user-attachments/assets/fe39b9a1-d914-4dea-b369-2b646e9da316" />

	- 주로 브라우저에서 자주 쓰는 문서를 저장할때 쓴다. 	

  <img width="633" height="398" alt="image" src="https://github.com/user-attachments/assets/11e7aace-82bf-4196-a1b0-1d260603db95" />


- **공용 프락시 캐시(public cache)**
	- 공유된 캐시
    
  <img width="746" height="257" alt="image" src="https://github.com/user-attachments/assets/be13cb0e-a092-43bb-8641-05f992878004" />

	- 로컬 캐시에서 문서 제공 or 사용자 입장에서 서버에 접근
	
	- 여러 사용자가 접근 → 불필요한 트래픽 감소
	<img width="638" height="381" alt="image" src="https://github.com/user-attachments/assets/ee264f5a-d3ed-4fe3-80b0-b4b86141a1c3" />


- 프락시 캐시 계층
	- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 방식.

	<img width="924" height="692" alt="image" src="https://github.com/user-attachments/assets/19eea6ca-2728-4fe2-aff9-f30a89aabe83" />

> 단, 캐시 계층이 깊다면, 요청은 캐시의 긴 연쇄를 따라갈수 있으므로, 성능 저하가 발생할수 있다.

- 캐시망
	- 프락시 캐시끼리 대화하여, 요청을 어떻게 처리할지 동적으로 결정하는 방식.
	
	- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시가 할 수 있는 일:
		- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
		- URL에 근거하여 **특정** 부모 캐시를 동적으로 선택
		- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 탐색
		- 다른 캐시들이 그들의 캐시된 컨텐츠에 부분적으로 접근 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않음.
			- 인터넷 트랜짓: 트래픽이 다른 네트워크로 건너가는 것

	- 형제 캐시 시스템(선택적 피어링)
		- 여러 캐시 서버가 서로의 캐시된 콘텐츠에 대해 부분적으로 접근할 수 있도록 허용하는 방식.
		- *피어링: 서로 다른 인터넷 네트워크가 연결되고 트래픽을 교환하는 과정.*

<img width="921" height="567" alt="image" src="https://github.com/user-attachments/assets/016db573-6807-4e2c-9b3a-392b353c03de" />


> HTTP는 형제 캐시를 지원하지 않기 때문에, 사람들은 인터넷 캐시 프롵토콜(ICP)이나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장한다.

---

## 7.7 캐시 처리 단계

- **HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 잘차**

<img width="925" height="600" alt="image" src="https://github.com/user-attachments/assets/0062e104-7813-4b03-b351-16dba2b10587" />


1. 요청 받기
	- 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱
	- 메시지를 파싱하여 URL과 헤더들을 추출.
3. 검색
	- 로컬 복사본이 있는지 검사.
		- 없다? → 사본을 받아온다(로컬에도 저장)
4. 신선도 검사
	- 사본이 충분히 신선한지 검사.
		- 신선 X? →  서버에게 변경사항 물어보기
5. 응답 생성
	- 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
	- 클라이언트에 맞게 헤더를 조정할 책임이 있음.
	- 종종 캐시 신선도 정보를 삽입한다(Cache-Control, Age, Expires 헤더 등)
	- **주의** Date 헤더를 조정해서는 안 된다.
6. 발송
	- 네트워크를 통해 응답을 클라이언트로 돌려준다
7. 로깅
	- 선택적으로, 트랜잭션에 대해 서술한 로그 하나를 남긴다.
	- 대포적으로 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷을 사용.

- **캐시 처리 프로 차트**
<img width="919" height="518" alt="image" src="https://github.com/user-attachments/assets/8317b9f8-c36e-48f8-8535-59abc10d864d" />


---

## 7.8 사본을 신선하게 유지하기
- HTTP가 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘.

- **문서 만료**
	- Cache-Control(NEW)과 Expires(OLD)라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌.
	<img width="865" height="217" alt="image" src="https://github.com/user-attachments/assets/c5cc41de-7052-4503-8fdd-f518f4942bd9" />

	- **유효기간 관련 헤더 설명**
	<img width="928" height="349" alt="image" src="https://github.com/user-attachments/assets/2525c803-d5bb-4ed6-8aa8-da8424f78db5" />


- **서버 재검사**
	- 캐기된 문서 만료 == 신선함 검사 NOT 문서가 다르다	
	- 재검사 결과:
		- 변경 **O**? 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 전송.
		- 변경 **X**? 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신.
	- HTTP가 캐시한테 요구하는 것:
		- '충분히 신선한' 캐시된 사본
		- 대검사 했기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
		- 에러 메시지(재검사해야한 서버가 다운된 경우)
		- 경고 메시지가 부착된 캐시된 사본(부정확하다면)

- **조건부 메서드와의 재검사**
	- HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해준다.
		- '변경되었으면 보내달라'
	- 모든 조건부 헤더는 `If-` 접두어로 시작.
	- 캐시 재검사에 사용되는 조건부 헤더
		- `If-Modified-Since` (IMS) : 날짜 재검사
			- `If-modified-Since: <캐시된 마지막 수정일>`
			- 변경되었다면, GET 요청은 성공할 거고 새 문서와 새 만료 날짜 정보들을 담은 응답이 캐시에게 반환될 것이다.
			- 변경된 게 아니라면 서버는 304 Not Modified를 클라이언트에게 돌려줄 것이다.
			- 서버 응답 헤더의 Last-Modified 헤더와 함께 동작.
			- **동작 예시**

		  <img width="699" height="680" alt="image" src="https://github.com/user-attachments/assets/abd20ff6-ec48-419e-b0f8-6c9370bf4c9d" />


			-웹 서버는 If-Modified-Since를 실제 날짜 비교로 구현하지 않고, IMS 날짜와 최근 변경일 간의 문자열 비교를 수행.
			- 즉, “이 날짜 이후로 변경되었다면”이 아니라, “정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면”의 의미로 동작.
		- `If-None-Match` : 엔티티 태그 재검사
			- `If-None-Match: <태그>`
			- **적절히 행해지기 어려운 상황:**
				- 어떤 문서가 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터인 경우
				- 너무 사소하거나 중요하지 않은 변경
				- 서버가 자신이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없는 경우
				- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버(정밀도 부족)
			- 엔터티 태그가 변경되면 캐시는 새 문서의 사본을 얻기(`GET`) 위해 `If-None-Match` 조건부 헤더를 사용 가능

		  <img width="697" height="288" alt="image" src="https://github.com/user-attachments/assets/ee5ed146-38d3-4806-8051-772878165544" />


			- Etag가 같으면 캐시와 서버가 일관된 상태이므로 서버에게 재검사 요청 시, 304 Not Modified를 반환할 거다. 다르면 새 내용과 새 태그를 담아 200 OK를 보낼 거다.
			
			- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 이 사실을 서버에게 알려주기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있다.
			
			```jsx
                	If-None-Match: "v2.6"
                	If-None-Match: "v2.4", "v2.5", "v2.6"
                	If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
                	```

	- 만약 서버가 모든 캐시된 사본을 무효화 시키지 않고 살짝만 문서를 고치고 싶을 수도 있다.
		- HTTP/1.1은 조금 변경되어도 같다고 표현하는 '약한 검사기(weak validator)'를 지원한다. W/ 접두사로 약한 검사기를 구분한다.
			- Etag: W/"v2.6"
			- If-None-Match: W/"v2.6"
		> 단, 특정범위 가져오기 같은 동작은 지원되지 않는다.
		- 반면, 강한 검사기는 콘텐츠가 바뀔 때마다 바뀌는 것을 의미한다. 강한 엔티티 태그는 무조건 태그가 매번 바뀔 것이다.
		- **주의** 서로 다른 두 객체에 같은 강한 엔터티 태그는 사용하지 말아야 하며, 서로 의미가 다른 약한 엔터티 태그값을 재활용해서도 안된다.
	
	- **언제 엔티티 태그를 사용하고, 언제 Last-Modified 일시를 사용하는가**
		- HTTP/1.1 클라이언트는 서버가 만약 "엔티티 태그"를 반환했다면, 반드시 엔티티 태그 검사기를 사용해야 한다.
		- 만약 서버가 "Last-Modified"를 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.
		- 둘 다 사용 가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있게 클라이언트는 각각을 위해 두 가지 재검사 정책을 모두 사용해야 한다.
		- **주의** 캐시나 서버는 If-Modified-Since와 엔티티 태그 조건부 헤더를 모두 받았다면, 모든 조건부 헤더에 부합하지 않는 한 304 Not Modified를 반환하면 안된다.

---

## 7.9 캐시 제어

- HTTP는 아래 헤더들을 통해, 문서가 만료되기 전까지 얼마나 오랫동안 캐시를 사용하게 할 지 정할 수 있다.	
  - Cache-Control: no-store
  - Cache-Control: no-cache
  - Cache-Control: must-revalidate
  - Cache-Control: max-age
  - Expires 날짜 헤더

 
- **no-cache와 no-store 응답 헤더**
  - HTTP/1.1은 신선도 관리를 위해 객체를 캐시하는 것을 제한하거나, 캐시된 객체를 제공하는 방법을 제공한다. 여기서 위 두 헤더는 캐시 서버가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.
  - no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다.
  - no-cache: 로컬 캐시 저장소에 저장 가능하나, 클라이언트에게 제공하기 위해서는 재검사를 해야한다.
  
  - Pragma: no-cache라는 응답 헤더도 있기는 하나, 이는 HTTP/1.1과 1.0+의 하위호완성을 위해 사용되므로,  HTTP 1.0+와 소통하지 않는 이상 Cache-Control: no-cache를 사용해야 한다.


- **Max-Age 응답 헤더**
  - 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다.
  - **NOTE** 
    - s-maxage라는 헤더도 존재하나, 이는 공용 캐시에만 적용.
    - 서버가 헤더 값을 0으로 설정함으로써, No-cache와 같은 역할 또는 리프레시하지 않도록 요청할 수 있다.


- **Expires 응답 헤더**
  - 더 이상 사용하지 않기를 권하는 헤더로, 초 단위 시간 대신에 실제 만료 날짜를 명시한다.
  - EX) *Expires: Fri, 05 Jul 2002, 05:00:00 GMT*


- **Must-Revalidate 응답 헤더**
  - `Cache-Control: must-revalidate`
  - 특정 캐시들은 만료된 문서들을 제공할수 있는데, 원 서버에서 이를 방지하기 위해서 사용할수 있다.
  - 문서가 만료되면, 캐시 서버의 설정에 상관없이 재검사를 해야 한다.
  - 신선도 검사를 할수 없는 상태라면, 504 Gateway Timeout error를 반드시 반환해야 한다.


- **클라이언트 신선도 제약**
  - 웹 브라우저에서 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신하는 리프레시 버튼이 있다.
  - 이  버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜서 강제로 재검사하거나, 서버로부터 콘텐츠를 무조건 가져온다.
  - 클라이언트도 Cache-Control 요청 헤더를 사용해, 만료 제약을 관리할 수 있는데, 상황에 따라 잘 판단하면 된다.
  - **요약표**
  <img width="700" height="430" alt="image" src="https://github.com/user-attachments/assets/2c641064-ad6e-4bb9-a106-325a2083546a" />


