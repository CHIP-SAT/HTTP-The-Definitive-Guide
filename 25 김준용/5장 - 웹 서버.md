**DISCLAMER:** THERE *WILL* BE MISTAKES HERE. TAKE IT WITH A SPOON OF SALT.

# 5장 - 웹 서버

## 다체로운 웹 서버
> The hell is a web server?

- 웹 서버: HTTP 요청을 처리하고 응답을 제공하는 소프트웨어와 웹페이지 제공에 특화된 장비를 통틀어서 말하는 용어.
- HTTP 및 그와 관련된 TCP 처리를 구현한 것.

- 웹 서버의 (소프트웨어/로직) 역할: HTTP 프로토콜 구현, 자신이 제공하는 웹 리소스 관리, 웹 관리 기능을 제공.
- 웹 서버의 (OS) 역할: 시스템 하드웨어 관리, TCP/IP 네트워크 지원, 웹 리소스 유지하기 위한 파일 시스템, 현제 연산 제어를 위한 프로세스 관리 제공.
- 공동 책임: TCP 커넥션 관리  (Why? HTTP 프로토콜)

## 웹 서버 구현
> *You* get a web server! *You* get a web server! Everyone gets a web server!

웹 서버의 여러가지 형태:
- 표준 컴퓨터에 설치 가능한 다목적 소프트웨어 웹 서버 (친구랑 마크할때 로컬 서버 여는거와 비슷한것 같음)
- 하드웨어와 소프트웨어 등이 미리 설치 및 설정된 기기 사기 (마트 가면 대스크탑 다 조립한 상태로 파는거 사는거랑 비슷?) Also known as Web Server Appliances... I think. *This book is older than me, OK? I'm sorry!*
- 전자기기 안에 몇게의 컴퓨터 칩 만으로 구현하여, 웹 서버를 관리 콘솔 등으로 제공하는 임베디드(Embedded) 웹 서버 
> Side note: Those embedded servers can get fricken *tiny*! like 1cm squared tiny! *And this book's from at most 2002!*

### 다목적 소프트웨어 웹 서버
> Runs on just about any wide spread hardware and OS! Also, they are NOT Operating Systems!

- 어지간한 운영체제에 동작하는 웹 서버 소프트웨어.
아파치나(Apache) 직소(Jigsaw) 같은 오픈 소스 소프트웨어나 마이크로소프트나 아이플래닛(IPlanet)같은 상용 소프트웨어를 말한다.

*물론 이게 다는 아니다. 특수 목적용, 커스텀 소프트웨어의 수도 만만하지 않다. 그러나 위의 넷이 가장 많이 쓰이는 소프트웨어다. (2002년 기준)*

### Web Server Appliances
> 'Plug-and-Play' servers! ...wait, what do you mean it's not in the translated book. WAIT. WHAT DO YOU MEAN IT'S CONSIDERED RETRO?!

- 구매자가 일일이 설정과 설치를 할 필요 없이 모두 이미 다 깔리고 설정된 웹 서버.
> Sun/Cobalt RaQ web appliances, Toshiba Magnia SG10, IBM Whistle web server appliance 등

- 업그래이드와 기능과 유동성이 부족한 점 외에는 간편하고 일반인도 접근할수 있게 만들어진 기기.
- 레트로?????

### 임베디드 웹 서버
> *crunch* Wait a minute... this *isn't* a chip!  ...James, that's our embedded chip demo model.   Eh, close enough. *Continues chewing*

- 프린터나 가전제품등에 내장되어 소비자가 웹 브라우저 인터페이스로 관리하게 해준다. (이거 근데 보안 문제 있지 않나?)
- **MAXIMUM MINIMALIST** : *꼭* 필요한 기능만 주로 탑재.

## 간단한 펄 웹 서버
> I know it's pretty outdated, but then again, *2002*

- 웹 서버를 완전히 구성하기 위해서는 상당한 양의 노력이 필요하다. 2002년 당시에 Apache(아파치)는 부가적인 처리 모듈을 뺀 코어만 5만 줄 이상의 코드를 갖이고 있었는걸 보면 엄두가 나지 않을 것이다. 

- 그럼 임베디드 웹 서버는 어케 있음? 
- **완전한** 웹 서버가 아니니깐 존재할수 있다. 최소한의 기능만 구현하고 싶으면 30줄의 perl 코드로도 가능하다. 예시로 Type-O-Serve 를 들어보자.

```
#!/usr/bin/perl
use Socket;
use Carp;
use FileHandle;

# (1) 명령줄에서 덮어쓰지 않는 이상 8080 포트를 기본으로 사용
$port = (@ARGV ? $ARGV[0] : 8080);

# (2) 로컬 TCP 소켓을 생성하고 커넥션을 기다리도록(listen) 설정한다.
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지 출력
printf(" <<<Type-O-Serve Accepting on Port %d>>>\n\n",$port);

while (1)
{
 # (4) 커넥션 C 를 기다린다
 $cport_caddr = accept(C, S);
 ($cport,$caddr) = sockaddr_in($cport_caddr);
 C->autoflush(1);

 # (5) 누구로부터 커넥션인지 출력한다
 $cname = gethostbyaddr($caddr,AF_INET);
 printf(" <<<Request From '%s'>>>\n",$cname);

 # (6) 빈 줄이 나올 떄까지 요청 메시지를 읽어서 화면에 출력한다
 while ($line = <C>)
 {
 print $line;
 if ($line =~ /^\r/) { last; }

 # (7) 응답줄을 위한 프롬프트를 만들고, 응답줄을 입력 받는다.
 # "." 하나만 입력되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.
 printf(" <<<Type Response Followed by '.'>>>\n");
 while ($line = <STDIN>)
 {
 $line =~ s/\r//;
 $line =~ s/\n//;
 if ($line =~ /^\./) { last; }
 print C $line . "\r\n";
 }
 close(C);
}
```

- HTTP 커넥션을 기다리고, 받은 메시지를 띄워주고, 사람이 직접 답장을 보내주는 도구이다. 특히나 HTTP 요청 메시지를 정확하게 기록하고, 그 어떤 HTTP 응답 메시지라도 돌려볼수 있게 해준다.
- 클라이언트와 프락시의 간의 상호작용 테스트에 유용한 진단 툴.
- 웹서버 체험

**사용 예시**

<img width="944" height="637" alt="스크린샷 2025-08-05 161627" src="https://github.com/user-attachments/assets/274dd151-44cf-4c8b-806d-ead5a7f834dd" />

### 진짜 웹 서버가 하는 일 (minimalist 확장 버전)
> Okay, not *all* but most!
- 대부분 HTTP 서버가 공통적으로 하는 일

<img width="961" height="687" alt="스크린샷 2025-08-05 162434" src="https://github.com/user-attachments/assets/e16bcf10-a547-4711-94cf-29bdce02ff94" />


|작업|설명|
| --- | --- |
| 1. 커넥션을 맺는다 | 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다. |
| 2. 요청을 받는다 | HTTP 요청 메시지를 네트워크로부터 읽어 취한다. |
| 3. 요청을 처리한다 | 요청 메시지를 해석하고 행동을 취한다. |
| 4. 리소스에 접근한다 | 메시지에서 지정한 리소스에 접근한다. |
| 5. 응답을 만든다 | 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다. |
| 6. 응답을 보낸다 | 응답을 클라이언트에게 보낸다. |
| 7. 트랜잭션을 로그로 남긴다 | 로그파일에 트랜잭션 완료에 대한 기록을 남긴다. |

### STEP 1: 클라이언트 커넥션 수락
> I'm going in

이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있지 않는 이상, 클라이언트는 HTTP 메시지를 보내기 위해 서버에 대한 새 커넥션을 열 필요가 있다.

- 새 커넥션 다루기
> *The Bouncer*

    클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고, TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다.

    추가적으로, 웹 서버는 어떤 커넥션이든, 거절하거나, 즉시 닫을수 있다. (주로 서버를 악의적인 커넥션으로 부터 보호하기 위함이다)

- 클라이언트 호스트 명 식별
> Papers please!

    호스트명 룩업으로 트랜잭션 지연을 최소화하는 많은 대용량 웹 서버를 제외하고는, 대부분 웹 서버는 클라이언트의 구체적인 접근 제어와 로깅에 사용하기 위해 '역방향 DNS'를 사용한다.

    이게 왜 접근 제어와 로깅에 유용한지는 나도 모른다.

- ident를 통해 클라리언트 사용자 알아내기
> The problem Daemon

	몇몇 웹 서버는 또한 IETF ident 프로토콜을 지원한다. 이는 서버가 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다. 
    
	일반 로그 포맷의 구번째 필드는 각 HTTP ident 사용자 이름을 담고 있다.

동작:

<img width="967" height="404" alt="스크린샷 2025-08-05 173123" src="https://github.com/user-attachments/assets/8852a008-0a1a-4241-8beb-f49c0aaa9d98" />

|부분|설명|
| --- | --- |
| (a) | 클라이언트는 HTTP 커넥션을 연다 |
| (b) | 서버는 클라이언트의 identd 서버 포르(113) 을 향해 연다 |
| (c) | 새 커넥션에 대응하는 사용자 이름을 묻는 간단한 요청을 보낸다 |
| (d) | 서버는 ident 응답을 읽는다 |

	이 기술은 어디에 주로 쓰이나? 
	여러 문제상, 조직 내부에서만 잘 사용한다.

	Why?
	1. 많은 클라이언트 PC는 identd 신원확인 프로토콜 데몬을 실행하지 않는다
	2. ident 프로콜은 HTTP 트랜잭션을 유의미하게 지연한다
	3. 방화멱이 ident 트래픽을 막는 경우가 많다
	4. ident 프로토콜을 안전하지 않고, 조작이 쉽다
	5. 가상 IP 주소를 잘 지원하지 않는다
	6. 클라이언트 사용자 이름의 노출로 인한 프라이버시 침해 우려가 있다

## STEP 2: 요청 메시지 수신
> *You've got mail!*

<img width="954" height="380" alt="스크린샷 2025-08-05 173210" src="https://github.com/user-attachments/assets/771a7caa-325e-4272-9688-66a565a3d95c" />



위의 사진 처럼 커넥션 데이터가 도착하면, 그 데이터를 읽어 들이고 파싱하여, 요청 메시지를 수성한다.

**파싱 작업**
1) 각각 스페이스 한 개로 분리되어 있는 메서드, URI, HTTP 버전 번호를 찾는다. (요청줄은 CRLF 문자열로 끝)
2) 메시지 헤더를 읽는다. (각 줄른 CRLF로 끝)
3) 헤더의 끝을 의미하는 빈 줄(CLRF)을 찾아낸다. (존재하면)
4) 요청 본문이 있다면, Content-Length 헤더에 정의된 길이를 읽어 들인다.

**주의**: 네트워크 커넥션은 언제라도 무효화될 수 있으므로, 웹 서버는 파싱해서 이해 가능한 수준의 분량을 확보하기 전까지는 받은 데이터를 메시지 일부분을 메모리에 임시 저장해 둘 필요가 있다.

- 메시지의 내부 표현
> Fast & Furious, spreadsheet edition 

	몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 룩업 테이블이나, 포인터등의 자료 구조로 조각내어 저장한다.

EXAMPLE
<img width="941" height="479" alt="스크린샷 2025-08-05 174606" src="https://github.com/user-attachments/assets/c4997183-2e61-47ec-bc7d-60878bc6feaa" />

- 커넥션 입력/출력 처리 아키텍처
> Multi-tasking: EXTREME EDITION

	고성능 웹 서버는 수천 개의 커넥션을 동시에 열수 있게 지원하여, 전 세계의 다양한 클라이언트들과 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 해준다.
	웹 서버들은 언제라도 도착할수 있는 새로운 요청을 주시하고 있으며, 아키텍쳐에 따라, 요청 처리 방식도 달라진다.

	아래에는 이런 요청 처리 방식의 예들이다.
<img width="940" height="831" alt="스크린샷 2025-08-05 184157" src="https://github.com/user-attachments/assets/05e77a5c-1a9a-416e-9440-dfbf5ed982c2" />


|이름|설명|특징|
| --- | --- | --- |
| (a) - 단일 스레드 웹 서버 | 한 번에 하나씩 요청을 처리한다. 트랜잭션이 완료되면, 다음 커넥션이 처리된다. | 구성하기는 쉬우나, 성능이 상당히 딸린다. 로우 로드 서버나, 진단도구들에 적합하다. |
| (b) - 멀티프로세스와 멀티스레드 웹 서버 | 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 홋은 고효율 스레드를 할당한다. | 스레드를 필요할때마다 만들거나 미리 만들수 있다. 그러나 스레드가 너무 많을때 메모리나 시스템 리소스를 과소비한다. (결국 최대 개수 제한함) |
| (c) - 다중 I/O 서버 | 모든 커넥션의 활동을 감시하여, 상태가 바뀌면 커넥션에 대해 작은 양의 처리가 수행된다. | 실제로 할일이 있을때만 작업을 수행하여, 리소스 낭비가 적다. |
| (d) - 다중 멀티스레드 웹 서버 | 여러 개의 스레드를 동원하여, 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다. | 멀티프로세스와 멀티스레드 웹 서버에 다중 I/O 서버의 리소스 절약 기능을 붙인 것이나 다름이 없다. |

### STEP 3: 요청 처리
> Literally message processing

웹 서버가 요청을 받으면, 서버는 요청으로부터 메서드, 리소스, 헤더, 본문 등을 얻어내어 처리한다.

### STEP 4: 리소스의 매핑과 접근
> WHAT. DOES. IT. MEAAAAAAAAAAAAAAAAAAN?!	

웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메시지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아야 한다.

- Docroot
> Funny name

	웹 서버의 가장 단순한 리소스 매핑의 형태는 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다. 
	이 파일들과 같은 웹 콘텐츠를 넣기 위해 예약해둔 폴더를 문서 루트 혹은 docroot라고 부른다.

**작동 예시**

<img width="965" height="334" alt="스크린샷 2025-08-05 184106" src="https://github.com/user-attachments/assets/9aacd9ca-edd7-462c-ac8b-3b3e6cbcc24b" />

**주의**: 서버는 상대적인 url이 docroot를 벗어나서 파일 시스템의 docroot 이외 부분이 노출되는 일이 생기지 낳도록 주의해야 한다.

- 가상 호스팅된 docroot
> Digital Roommates, ey?

	가상 호스팅 웹 서버는, 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅 한다. 
	이런 상황에서는 docroot는 URI나 Host 헤더에서 얻은 IP 주소나 호스트 명을 히용해 올바른 문서 루트를 식별한다.

**작동 예시**

<img width="941" height="482" alt="스크린샷 2025-08-05 185422" src="https://github.com/user-attachments/assets/9bd9db3b-e487-4523-8975-6fc508f5a74f" />


**Honorable Mention: 아파치 docroot 설정**

<img width="398" height="390" alt="스크린샷 2025-08-05 185519" src="https://github.com/user-attachments/assets/8df02f85-4bd3-4fb3-b954-435d8b14a3a3" />

(자세한 정보는 18장의 '가상 호스팅'을 보라)

- 사용자 홈 디렉터리 docroots
> docroot, the digital landlord

	docroot의 또 다른 재표적 활용은, 한 대의 웹 서버에 각자의 개인 웹 사이트를 만들 수 있도록 해주는 것이다. 
	보통 '/~' 다음에 사용자 이름이 오는 것으로 시작하는 URI는 그 사용자의 개인 문서 루트를 가리킨다.
	개인 docroot는 주로 사용자 홈 디렉터리 안에 있는 public_html로 불리는 디렉터리지만, 설정에 따라 다를수 있다.

**작동 예시**

<img width="945" height="313" alt="스크린샷 2025-08-05 190609" src="https://github.com/user-attachments/assets/b61eeb3b-05d8-4742-b79d-4b8167b155ae" />

- 디렉터리 목록
> Folders? Folders.

	경로 파일이 아닌 디렉터리는 가리키는, 디렉터리 URL에 대한 요청을 받았을떄, 몇 가지 다른 행동을 취하도록 설정할 수 있다:
    
	1. 에러 반환
	2. '색인 파일' 반환 (index.html/index.htm)
	3. 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지 반환
 
	많은 웹 서버는 디렉터리 URI를 요청했을 때 기본 색인 파일이 없고 디렉터리 색인 기능이 꺼져 있지 않다면, 자동으로 그 디렉터리의 파일들을 크기, 변경일 및 그 파일에 대한 링크와 함께 열거한 HTML 파일을 반환한다. (그러나 이는 원치 않은 파일도 들어낼수 있다)

- 동적 콘텐츠 리소스 매핑

    웹 서버는 URI를 동적 리소스에 매핑할 수도 있다. 대부분의 웹 서비스는 동적 리소스를 식별하고 매핑할수 있으며, 더 복잡한 백앤드 등을 연결하기 위해 특수한 웹 서버인 '웹 애플리케이션'을 사용할 수도 있다.

- 서버사이드 인클루드(SSI)
> WHAT ARE SERVER-SIDE INCLUDES, WHAT ARE THEY?!

	리소스의 콘텐츠를 처리해서 보내주라는 스크립트? 잘 모름. 이게 뭐라고 명확하게 설명되지는 않음, 그냥 지원한다고 말하고, 뭐하는지는 애매함.

- 접근 제어

	웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있다.
	Ip 접근 제어, 또는 비밀번호등을 물어볼수 있다.

### STEP 5: 응답 만들기
> RESPONSE? THIS TOOK *TOO* MUCH TIME!

- 응답 엔터티
	응답 본문이 생성되면, 다음을 포함:
	1) 응갑 본문의 MIME 타입을 서술하는 Content-Type 헤더
	2) 응답 본문의 길이를 서술하는 Content-Length 헤더
	3) 실제 응답 본문의 내용

- MIME 타입 결정하기
> Are we in France? What's with all the mimes?

MIME 타입과 리소스를 연결하는 여러 가지 방법:
|방법|설병|
| --- | --- |
| mime.types | 파일 이름의 확장자를 사용. MIME 타입이 담겨있는 파일 탐색. 가장 흔한 방법.  |
| 매직 타이핑(Magic Typing) | 파일 내용을 검사해서 알려진 패턴에 대한 테이블에 해당 패턴이 있는지 찾는다. (느리긴 하나, 확장자가 없을때 특히 편리하다) |
| 유형 명시(Explicit typing) | 특정 파일이나 디렉터리 안의 파일들이 파일 확장이나 냐용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버를 설정할 수 있다. |
| 유형 협상(Type negotiation) | 하나의 리소스가 여러 종류릐 문서 형식에 속하도록 설정할 수 있다. 이후 클라이언트가 사용하기 가장 좋은 형식을 판별할 것인지의 여부도 설정할 수 있다. |


- 리다이렉션

> Thank you for waiting, please go to table five.

    웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다. 이는 3XX 상태 코드로 지칭된다.

	1. 영구히 리소스가 옮겨진 경우: 클라이언트는 바뀐 위치로 북마크를 갱신하고 이때 301 Moved 상태코드를 사용한다. 

	2. 임시로 리소스가 옮겨진 경우: 서버는 클라이언트를 리다이렉트 하면서, 임시로 바꼈으니 북마크를 갱신하지 않게 303 See Other과 307 Temporary 상태 코드를 사용한다.

### STEP 6: 응답 보내기
클라이언트가 서버에 보내는 것과 마찬가지로 서버도 커넥션 이슈를 직면하므로, 서버는 커넥션 상태를 추적해서 관리해주어야 한다.

지속적인 커넥션이면, Content-Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우나, 클라이언트가 응답이 언제 끝나는지 알 수 없는 경우에, 커넥션은 연린 상태를 유지할 것이다.

### STEP 7: 로깅
트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다.

후기: 뭔가 너무 많이 적음...
