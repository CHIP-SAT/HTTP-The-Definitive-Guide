## 개별 접촉
HTTP는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜이다.

웹 서버는 요청을 보낸 사용자를 식별하거나, 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

- 개별 인사: 개인에게 맞춰져 있는 것처럼 느끼게 메시지나 페이지 생성.
- 상용자 맞춤 추천: 고객의 흥미가 무엇인지 학습하여, 좋아할 만한 제품을 추천.
- 저장된 사용자 정보: Remember. 신용카드나 주소를 저장하여, 매번 입력하지 않게 해주는 서비스.
- 세션 추적: 사이트와의 상호작용을 위해 사용자의 상태를 남신다. (ex: 장바구니)

이처럼 이는 주로, 사이트를 개인화 시키는데 유용하다.

## HTTP 헤더

사용자 정보를 전달하는 가장 일반적인 일곱 가지 HTTP 요청 헤더.

<img width="928" height="364" alt="image" src="https://github.com/user-attachments/assets/91770aef-4968-4bf1-8349-a28acddc43d1" />


- `From`: 사용자 이메일 주소를 포함. (그러나 이는 개인 문서이므로, 조심히 사용)
- `User-Agent`: 사용중인 브라우저 이름, 버전 정보, 그리고 어떤 경우에는 OS 정보. (최적화에 유용)

*그러나, 이 정보들로는 특정 유저를 식별하기에 부족하다.*

## 클라이언트 IP 주소
초기에는 IP 주소를 사용하여 사용자를 식별하려 함.
거의 바뀌지 않고, 클라이언트 IP를 알 수 있다면 문제 없이 작동하기 때문에 고려함.

### BUT

- IP는 사용자가 아니라 **컴퓨터**를 가리킨다. (여럿이 사용하는 거면 식별 X)
- ISP는 사용자가 로그인하면 동적으로 IP 주소를 할당. (시간에 따라서, 사용자는 다른 주소를 받으므로, 웹 서버는 사용자를 IP 주소로 식별 X)
- IP를 숨기는 보안이 있으면 작동 X
- HTTP 프락시와 게이트웨이가 원 서버에 새로운 TCP 연결을 하려 하여, 서버는 클라이언트가 아니라, 프락시 서버의 IP 주소를 본다.

이러므로, 대중적으로 사용하지는 않는다.
인트라넷 같이 제한된 영역에서나 적절함.

## 사용자 로그인
IP 주소로 사용자 식별하는 수동적인 방식보다, 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해 명시적으로 식별을 요청할 수 있다.

- 서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한더면, HTTP 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.
- `WWW-Authenticate`와 `Authorization` 헤더를 사용해, 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 사이트에 한 번만 로그인하면, 브라우저는 요청마다 해당 사용자의 식별정보 토큰을 `Authorization` 헤더에 담아 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지한다.

그러나 로그인하는 거는 귀찮다.

## 뚱뚱한 URL
어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적했다.

보통 URL 경로의 처음이나 끝에  어떤 상태 정보를 추가해 확장한다.
사용자가 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼 링크를 동적으로 생성한다.

이렇게 사용자 상태 정보를 포함하는 URL을 뚱뚱한 URL이라 부른다.

그러나 이는 보기 흉한 URL을 만들고, 공유 시 개인정보 유출 위험이 있으며, URL이 달라져 캐시 활용이 불가능하다.
또한 서버는 매번 해당 URL에 맞는 HTML 페이지를 새로 생성해야 하므로 부하가 증가하고, 로그아웃 시에는 세션 정보까지 사라지게 된다.

## 쿠키
쿠키는 사용자를 식별하고, 세션을 유지하는 방식 중 현재까지 널리 사용하는 방식이다. 넷스케이프가 최초로 개발했고, 지금은 모든 브라우저에서 지원한다.

### 쿠키의 타입
쿠키는 `세션 쿠키(Session)`와 `지속 쿠키(Persistent)` 두 가지로 나누어 볼 수 있다.

- `세션 쿠키(Session)`
	- 사용자가 사이트를 탐색할 때, 관련 설정과 선호 사항을 저장하는 '임시 쿠키'이다.
	- 브라우저를 닫으면 삭제됨
- `지속 쿠키(persistent)`
	- 디스크에 저장되어, 브라우저를 닫거나, 컴퓨터를 재시작해고 남아있다.
	- 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용.

둘의 다른 점을 파기되는 시점뿐이다. 쿠키에 Discard 파라미터, Expries, Max-Age 파라미터가 없으면 세션 쿠키로 취급된다.

### 쿠키는 어떻게 동작하는가
쿠키는 서버가 사용자에게 "안녕 내 이름은 ..." 라고 붙이는 스티커와 같다고 한다. 사용자가 사이트를 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.

쿠키는 임이의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie2(확장 헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.

쿠키는 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적을 위한 용도의 식별번호만 포함하기도 한다.
<img width="926" height="744" alt="image" src="https://github.com/user-attachments/assets/b35a721e-ec1c-4b27-b873-e48ddb381e66" />


a) 사이트 처음 방문
b) id="34294"라는 쿠키를 **사용자**에게 할당. (서버는 이걸로 데이터베이스에서 사용자의 정보를 찾는데 사용할 수 있다.)
c) 미래에 같은 사이트를 방문하면, 부라우저는 서버가 이 사용자에게 할당했던 쿠키를 `Cookie` 요철 헤더에 기술하여 전송.

## 쿠키 상자: 클라이언트 측 상태
쿠키는 브라우저가 서버 관련 정보를 저장하고, 사용자가 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다.

브라우저는 쿠키 정보를  저장할 책임이 이있는데, 이 시스템을 '클라이언트 측 강태'라고 하며, 쿠키 명세서에서 이것의 공식적인 이름은 `HTTP 상태 관리 체계`이다.

파일 예시(Google Chrome):
<img width="1184" height="220" alt="image" src="https://github.com/user-attachments/assets/3adc6c27-9f07-40b8-aef9-65d1ee833609" />


## 사이트마다 각기 다른 쿠키들
브라우저는 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다.

이유:
- 쿠키를 모두 전달하면 성능이 크게 저하된다.
- 대부분은 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에, 대부분 사이트에서는 인식하지 않는다.
- 개인정보 유출 (But that was obvious, no?)

이런 이유로 브라우저는 보통 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

- **쿠키 Domain 속성**
	- 서버는 쿠키는 `Set-Cookie` 응답 헤더에 `Domain` 속성을 기술하여 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.
	`ex) Set-cookie: user='mary17'; domain="SpiritAir.com"`
	⇒  브라우저가 user='mary17'이라는 쿠키를 .SpiritAir.com 도메인을 가지고 있는 모든 사이트에 전달하라는 의미다.

- **쿠키 Path 속성`
	- 웹 사이트 일부에만 쿠키를 적용
	- path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키 전달 가능
	`ex) Set-cookie: pref=compact; domain="SpiritAir.com"; path=/autos/`
	⇒ 사용자가 `http://www.SpiritAir.com/autos/cheapo/index.html`로 접근하면 `Cookie: user="mary17"`, `Cookie: pref=compact` 두 개의 쿠키를 얻게 됨. 그 외에는 `Cookie: user="mary17"`만 얻게 됨.

## 쿠키 구성요소
현재 사용되는 쿠키 명세에는 Version 0 쿠키(흔히 '넷스케이프 쿠키')와 Version 1쿠키('TFC 2965')가 있다. (그러나 Version 1은 Version 0 쿠키의 확장이므로, 널리 쓰이지는 않는다.

- Version 0 Set-Cookie 헤더
<img width="923" height="541" alt="image" src="https://github.com/user-attachments/assets/4b72080a-d1b1-403a-91c9-7c5a9cdc58b6" />
<img width="930" height="774" alt="image" src="https://github.com/user-attachments/assets/31812ed7-c52d-4809-a84e-1c255242521d" />


- Version 0 Cookie 헤더
모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보냄.
`Cookie: session-id=002-1145265-8016838; session-id-time=1007884800`

- Version 1(RFC 2965) 쿠키
RFC 2965는 폐기되어 더 이상 지원되지 않음.

## 쿠키와 세션 추적
쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.

Amazon.com 사이트는 세션 쿠키를 이용해서 사용자를 추적함.
<img width="655" height="783" alt="image" src="https://github.com/user-attachments/assets/96ada873-f128-4dd0-be82-6286f78c14dd" />


## 쿠키와 캐싱
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것을 주의해야 함.
- **캐시를 다루는 기본 원칙**
	- **캐시되지 말아야 할 문서가 있다면 표시하라**
		- 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면, 문서에 명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술
		- 캐시를 해도 되는 문서에 Cache-Control: public을 사용하면 웹의 대역폭을 더 절약시켜줌.
	- Set-Cookie 헤더를 캐시 하는 것에 유의하라
		- 만약 응답이 Set-Cookie 헤더를 가지고 있으면, 본문은 캐시할 수 있지만 Set-Cookie 헤더를 캐시하는 것에는 주의
		- 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패하기 때문
		- 어떤 캐시는 응답을 저장하기 전에 Set-Cookie 헤더를 제거하기 때문에, 그 캐시 데이터를 받는 클라이언트는 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
			-해결책: 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술
				- 원 서버는 Cache-Control: must-revalidate, max-age=0 헤더를 캐시된 문서에 추가함으로써 재검사가 일어나게 할 수 있음.
	- Cookie 헤더를 가지고 있는 요청을 주의하라

## 쿠키, 보안 그리고 개인정보
원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있음.

그냥 잘 사용하고 표준적으로 잘 쓰면 문제 없음.
