## 11.1 개별 접촉

**HTTP**: 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜

클라이언트(요청) → 서버(응답) → 클라이언트

웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있음.

현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 함 → 네트워크로 연결된 사용자들에 대해 더 많은 것을 알고 싶어 하고 사용자들이 브라우징하는 것을 기록하고 싶어 함 → 여러 가지 방식으로 사이트를 개인화시켜서 사용자에게 제공

**개별 인사**: 온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용 만듦

**사용자 맞춤 추천**: 온라인 상점은 고객 흥미를 학습해서 좋아할 것이라고 예상되는 제품들을 추천. 고객에게 중요한 날이 다가오면 특별한 제품을 제시하기도 함

**저장된 사용자 정보**: 고객을 한번 식별하고 나면 저장된 사용자 정보를 사용할 수 있음. 복잡한 주소와 신용카드 정보를 매번 입력할 필요가 없도록 이런 정보를 데이터베이스에 저장

**세션 추적**: HTTP 트랜잭션은 상태가 없고 각 요청 및 응답은 독립적으로 일어남. 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있도록 사용자의 상태를 남김.(장바구니 등) 이러한 상태를 유지하려면 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요

## 11.2 HTTP 헤더

| 헤더 이름 | 헤더 타입 | 요청 |
| --- | --- | --- |
| From | 요청 | 사용자의 이메일 주소 |
| User-Agent | 요청 | 사용자의 브라우저 |
| Referer | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| Authorization | 요청 | 사용자 이름과 비밀번호 |
| Client-ip | 확장(요청) | 클라이언트의 IP 주소 |
| X-Forwarded-For | 확장(요청) | 클라이언트의 IP 주소 |
| Cookie | 확장(요청) | 서버가 생성한 ID 라벨 |
- From 헤더: 사용자의 이메일 주소 포함하여 사용자 식별. but 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제 때문에 이 헤더를 보내는 브라우저는 많지 않음.
- User-Agent 헤더: 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보까지 포함하여 서버에게 알려줌. 이는 특정 브라우저에서 제대로 동작하도록 그 속성에 맞추어 콘텐츠를 최적화하는 데 유용할 수 있지만, 특정 사용자를 구분하는 데는 큰 도움 안 됨.
- Referer 헤더: 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킴. 이 헤더 자체만으로 사용자를 식별할 수는 없지만, 사용자가 이전에 어떤 페이지를 방문했었는지는 알려줌 → 사용자의 웹 사용 행태나 취향을 더 잘 파악 가능

## 11.3 클라이언트 IP 주소

**클라이언트의 IP 주소**: 보통 HTTP헤더에 없지만 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP주소를 알아낼 수 있음 (예: 유닉스 시스템에서 getpeemame 함수 호출 → 클라이언트 IP주소 받음)

**사용자 식별에 클라이언트의 IP 주소를 사용하는 방식**: 사용자가 확실한 IP 주소를 가지고 있고, 그 주소가 절대 바뀌지 않으며 웹 서버가 요청마다 클라이언트의 IP를 알 수 있다면 문제없이 동작

<IP 주소로 사용자를 식별하는 방식의 약점>

- 클라이언트 IP 주소 == 사용자가 사용하는 컴퓨터 (NOT 사용자) → 여러 사용자가 같은 컴퓨터를 사용한다면 식별 불가능
- 많은 인터넷 서비스 제공자(ISP): 사용자가 로그인하면 동적으로 IP주소 할당 → 로그인한 시간에 따라 사용자는 매번 다른 주소 받음 → 웹 서버가 사용자 식별 불가능
- 많은 사용자가 보안 강화와 주소 관리를 위해 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용 → NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨김 → 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변경함
- HTTP 프락시와 게이트웨이 : 원 서버에 새로운 TCP 연결을 함 → 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP주소를 봄 (일부 프락시는 원본 IP 주소를 보존하려고 확장 헤더를 추가하여 이 문제를 해결하려 했으나 모든 프락시가 이렇게 동작하진 않음)
- 세션 간 사용자 추적 목적의 클라이언트 IP주소 사용 → 제대로 동작 X
- 보안 기능으로 특정 IP 주소로부터의 사용자에게만 문서 전달 → 인터넷에서는 IP주소 임의 변경 가능하여 문제 발생
- 클라이언트와 서버 사이에 있는 프락시도 문제 발생 가능

## 11.4 사용자 로그인

사용자 로그인: 사용자 이름과 비밀번호로 인증(로그인)할 것을 요구하여 사용자에게 명시적으로 식별 요청하는 방법. 한번 로그인하면 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보냄 → 웹 서버가 항상 확인 가능

웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가짐

서버에서 사용자가 사이트 접근하기 전에 로그인 요구하려면 HTTP 401 Login Required 응답 코드를 브라우저에 보냄 → 브라우저는 로그인 대화상자 보여줌, 다음 요청부터 Authorization 헤더에 그 정보를 기술하여 보냄

## 11.5 뚱뚱한 URL

보통 URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장함. → 웹 사이트에서 사용자의 URL마다 버전을 기술하여 사용자를 식별/추적 가능 (사용자가 사이트를 돌아다니면 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성)

**뚱뚱한 URL**:사용자의 상태 정보 포함하고 있는 URL

**뚱뚱한 URL의 용도**: 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 ‘세션’ 혹은 ‘방문’으로 묶는 용도 (사용자가 웹 사이트에 처음 방문 → 유일한 ID 생성 → 그 값은 서버가 인식 가능한 방식으로 URL에 추가 → 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트시킴)

**뚱뚱한 URL의 요청을 받은 서버**: 사용자 아이디와 관련된 추가적인 정보(쇼핑 카트, 프로필 등)를 찾아 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꿈

**<뚱뚱한 URL 기술의 문제점>**

- 못생긴 URL: 브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 줌
- 공유하지 못하는 URL: 뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함하기에 그 주소를 공유하면 사용자의 누적된 개인정보를 공유하게 됨
- 캐시를 사용할 수 없음: URL로 만드는 것 == URL이 달라지기 때문에 기존 캐시에 접근할 수 없음
- 서버 부하 가중: 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 함
- 이탈: 사용자가 뚱뚱한 URL 세션에서 이탈하기 쉬움. 이탈하면 사용자의 개인정보가 초기화됨
- 세션 간 지속성 부재: 사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상 로그아웃하면 모든 정보를 잃음

## 11.6 쿠키

사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식. 넷스케이프가 최초로 개발하여 지금은 모든 브라우저에서 지원함. 쿠키는 캐시와 충돌할 수 있어서 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음.

### 쿠키의 타입

쿠키는 크게 세션 쿠키와 지속 쿠키 두 가지로 나뉨.

**세션 쿠키**: 사용자가 사이트 탐색 시 관련한 설정과 선호 사항들을 저장하는 임시 쿠키. 사용자가 브라우저를 닫으면 삭제됨

**지속 쿠키**: 삭제되지 않고 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있음. 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용

**둘의 차이점**: 파기되는 시점

### 쿠키의 동작 과정

쿠키는 서버가 사용자의 소개를 적어 붙이는 스티커와 같음. 사용자가 웹 사이트에 방문하면 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있음

처음 사용자가 웹 사이트 방문 시 웹 서버는 사용자에 대해 모름 → 사용자가 다시 돌아왔을 때 웹 서버는 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당(쿠키는 임의의 이름=값 형태의 리스트를 가짐) → 그 리스트는 HTTP 응답 헤더(Set-Cookie/Set-Cookie2)에 기술되어 사용자에게 전달함

쿠키는 어떤 정보든 포함할 수 있지만 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 함.

쿠키는 단순히 ID 번호에만 국한되지 않고, 많은 웹 서버가 정보를 쿠키에 유지하려고 함

브라우저는 서버로 온 Set-Cookie/Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장함. 사용자가 미래에 같은 사이트를 방문하면 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술해 전송

### 쿠키 상자: 클라이언트 측 상태

**쿠키의 기본적인 발상**: 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것

브라우저가 쿠키 정보를 저장할 책임 시스템을 ‘클라이언트 측 상태(HTTP 상태 관리 체계)’라고 함.

**<브라우저별 쿠키 저장 방식>**

- 구글 크롬 쿠키: Cookies라는 SQLite 파일에 쿠키 저장
    - creation_utc: 쿠키 생성된 시점 알려줌
    - host_key: 쿠키의 도메인
    - name: 쿠키의 이름
    - value: 쿠키의 값
    - path: 쿠키와 관련된 도메인에 있는 경로
    - expire_utc: 쿠키의 파기 시점 알려줌
    - secure: 이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킴
- 마이크로소프트 인터넷 익스플로러 쿠키: 캐시 디렉터리에 각각의 개별 파일로 쿠키 저장. 인터넷 익스플로러의 쿠키 파일은 자체적인 형식을 가지고 기술되지만 필드 대부분은 이해하기 쉽게 되어 있음. 각 쿠키는 각 파일에 개별 저장되며 각 쿠키는 여러 행으로 되어 있음. (파일의 첫 번째 줄: 쿠키 이름, 두 번째 줄: 쿠키의 값, 세 번째 줄: 도메인과 경로, 나머지 줄: 쿠키에 대한 추가적 정보)

### 사이트마다 각기 다른 쿠키들

브라우저는 많은 쿠키를 가지고 있을 수 있지만 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않고, 보통 각 사이트에 두 개/세 개의 쿠키만을 보냄.

이유: 쿠키를 모두 전달하면 실제 콘텐츠 바이트보다 전달해야 할 쿠키 바이트가 더 많아 브라우저의 성능 크게 저하, 이 쿠키들은 대부분 사이트에서는 인식하지 않는 무의미한 값, 모든 사이트에 쿠키 전체를 전달하면 잠재적인 개인정보 문제를 일으킬 것

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 다긴 정보를 전달함.

많은 웹 사이트는 광고 관리하는 협력업체와 계약 → 이 광고들은 웹 사이트 자체의 일부인 것처럼 제작되고 지속 쿠키를 만들어냄. 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문 → 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송(지속 쿠키의 도메인이 같기 때문). 

광고사는 이 기술에 Referer 헤더를 접목하여 사용자의 프로필, 사이트 사용 습관에 대한 방대한 데이터 구축 가능. 최신 브라우저들은 개인정보 설정 기능을 통해 협력업체의 쿠키 사용 방식 제약 가능

- 쿠키 Domain 속성: 서버는 쿠키 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술 → 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어 가능
- 쿠키 Path 속성: 웹 사이트 일부에만 쿠키 적용 (URL 경로의 앞부분을 가리키는 Path 속성을 기술하여 해당 경로에 속하는 페이지에만 쿠키 전달)

### 쿠키 구성요소

현재 사용되는 쿠키 명세에는 Version 0 쿠키(넷스케이프 쿠키)와 Version 1 쿠키(’RFC 2965’)가 있음. Version 1 쿠키는  Version 0 쿠키의 확장으로 널리 쓰이지는 않음.

### Version 0(넷스케이프) 쿠키

최초의 쿠키 명세는 넷스케이프가 정의함. 이 쿠키는 Set-Cookie 응답 헤더, Cookie 요청 헤더, 쿠키를 조작하는 데 필요한 필드들을 정의함.

**<Version 0 Set-Cookie 헤더>**

 Set-Cookie 헤더는 쿠키의 이름과 값을 가져야 함. 이는 쿠키 옵션 속성들에 세미콜론으로 이어 기술.

- 이름=값: 필수 속성. ‘이름’과 ‘값’ 모두 큰따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열. 웹 서버는 사용자가 추후 다시 방문하면 읽어올 그 어떤 이름=값 조합이든 만들 수 있음. ( **Set-Cookie: customer=Mary** )
- Expires: 선택적인 속성. 쿠키의 생명주기를 가리키는 날짜 문자열을 기술. 파기 일자에 다다르면 그 쿠키는 삭제될 것이며 전달되지도 않을 것임. ( **요일, DD-MM-YY HH:MM:SS GMT** ) 사용할 수 있는 타임 존은 GMT뿐이며 날짜 요소 간에 구분자는 대시(-)여야 함. 쿠키에 Expires 명시하지 않으면 그 쿠키는 사용자의 세션 끝날 때 파기됨
- Domain: 선택적인 속성. 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트 명으로만 쿠키를 전송. 이는 서버가 특정 도메인에만 쿠키를 제한적으로 전달하게 함. 명시된 도메인에 해당하는 도메인들만이 쿠키를 설정할 수 있고, 2~3개 영역을 가지는 도메인을 기술해야 함. 도메인이 명시되어 있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용 ( **Set-Cookie: SHIPPING=FEDEX; domain=”joes-hardware.com”** )
- Path: 선택적인 속성. 서버에 있는 특정 문서에만 쿠키 할당 가능. Path 속성에 기술된 값이 URL 경로의 앞부분과 일치하면 쿠키 전달 ( **Set-Cookie: lastorder=00183; path=/orders** )
- Secure: 선택적인 속성. 쿠키는 HTTP가 SSL 보안 연결을 사용할 때만 쿠키 전송

클라이언트가 서버에 요청 보낼 때: Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서 아직 파기되지 않은 쿠키들을 함께 보냄. 모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보냄.

### Version 1 (RFC 2965) 쿠키

![KakaoTalk_20250829_162900356](https://github.com/user-attachments/assets/d9a14b04-3d01-4169-a0db-6601ecc608f2)

### 쿠키와 세션 추적

쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용됨.

![KakaoTalk_20250829_163224578](https://github.com/user-attachments/assets/3cc9f3c6-8af8-4e9b-bc67-09174fcb18c2)


a: 브라우저가 Amazon.com의 루트 페이지를 처음 요청

b: 서버는 클라이언트를 전자상거래 소프트웨어 URL로 리다이렉트시킴

c: 클라이언트는 리다이렉트 URL로 요청 보냄

d: 서버는 응답에 두 개의 세션 쿠키 기술하고 사용자를 다른 URL로 리다이렉트시킴, 클라이언트는 다시 이 쿠키들을 첨부하여 영상 보냄

e: 클라이언트는 새로운 URL을 요청을 앞서 받은 두 개의 쿠키와 함께 보냄

f: 서버는 home.html 페이지로 리다이렉트시키고 쿠키 두 개를 더 첨부함

g: 클라이언트는 home.html 페이지를 가져오고 총 네 개의 쿠키를 전달

h: 서버는 콘텐츠를 보냄

### 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 건 주의해야 함. (쿠키가 다른 사용자에게 할당, 개인정보 노출 가능성)

**<캐시를 다루는 기본 원칙>**

- 캐시되지 말아야 할 문서가 있다면 표시하기
- Set-Cookie 헤더 캐시 유의
- Cookie 헤더를 가지고 있는 요청 주의

### 쿠키, 보안 그리고 개인정보

쿠키는 비활성화, 대체가 가능하므로 자체가 보안상 위험은 아님.

개인정보/사용자 추적 기술은 잘못된 의도로 사용될 수 있기에 항상 조심해야 함.

오용: 협력업체 웹 사이트가 사용자 추적을 위해 지속 쿠키 사용

제공하는 개인정보를 누가 받는지 명확히 명확히 알고 사이트의 개인정보 정책에만 유의한다면 쿠키의 위험성보다 편리함(세션 조작, 트랜잭션)이 더 큼.
