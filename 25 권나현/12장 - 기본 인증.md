## 12.1 인증

### HTTP의 인증요구/응답 프레임워크

**HTTP**: 사용자 인증하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공

**<HTTP 인증 모델>**

![KakaoTalk_20250829_200524481](https://github.com/user-attachments/assets/7fce268a-fd65-4daf-8482-db8c7afa8d0f)


웹 애플리케이션이 HTTP 요청 메시지 받음 → 서버는 요청 처리하는 대신 개인정보를 요구하는 ‘인증요구’로 응답

사용자가 다시 요청 보낼 때는 인증 정보(ID, PW) 첨부해야 함.

인증 정보가 맞지 않으면: 서버는 클라이언트에 다시 인증요구를 보내거나 에러 발생.

인증 정보가 맞으면: 요청 문제없이 처리 완료

### 인증 프로토콜과 헤더

**HTTP**: 수정 가능한 제어 헤더를 통해 다른 인증 프로토콜에 맞춘 확장이 가능한 프레임워크 제공

헤더의 형식과 내용은 인증 프로토콜에 따라 달라짐

HTTP의 두 가지 공식적 인증 프로토콜: 기본 인증, 다이제스트 인증

**<네 가지 인증 단계>**

![KakaoTalk_20250829_200659202](https://github.com/user-attachments/assets/1210ce5a-a445-4569-93b8-a427cc7ff12e)


### 보안 영역

HTTP가 리소스마다 다른 접근 조건을 다루는 방법: 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나누고, 보안 영역은 저마다 다른 사용자 권한을 요구함.

## 12.2 기본 인증

가장 잘 알려진 HTTP 인증 규약.

기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있음. 서버는 401 상태코드와 함께 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작함. 인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는 사용자에게 계정과 비밀번호(접근 권한 검사)를 입력할 수 있는 대화상자를 열고, 사용자가 입력한 정보를 Authorization 요청 헤더 안에 암호화해서 서버로 전송

### 기본 인증의 예

![KakaoTalk_20250829_200809780](https://github.com/user-attachments/assets/855a098d-72b0-4e6d-b679-56a6c27fb0c4)


**<과정>**

1. 사용자가 자신이 가족사진인 /family/jejff.jpg를 요청
2. 서버가 WWW-Authenticate 헤더와 함께 개인 가족사진 접근 비번을 요구하는 401 응답 반환
3. 브라우저가 401 응답 받고 Family 영역의 사용자 이름과 비밀번호를 요구하는 대화상자 띄움. 사용자가 입력하면 브라우저는 그것들을 콜론으로 이어 붙이고, base-64 방식으로 인코딩하고, Authorization 헤더에 그 값을 담아 서버로 다시 전송
4. 서버가 사용자 이름을 디코딩하고, 그 값이 정확한지 검사한 후 문제가 없으면 200 메시지와 함께 요청받았던 문서 보냄

**<기본 인증 헤더>**

![KakaoTalk_20250829_200943059](https://github.com/user-attachments/assets/61797055-6b23-4ae6-9304-cf103dcfa968)


### Base-64 사용자 이름/비밀번호 인코딩

**HTTP 기본 인증**: 사용자 이름과 비밀번호를 콜론으로 이어서 합치고 base-64 인코딩 메서드를 사용해 인코딩 (8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환)

### 프락시 인증

**중개 프락시 서버**: 사용자들이 호사의 서버, LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증. 프락시 서버에서 접근 정책을 중앙 관리할 수 있음 → 회사 리소스 전체를 통합적으로 접근 제어 목적으로 사용

프락시 인증과 웹 서버 인증: 헤더와 상태 코드만 다르고 절차는 같음

**<대조표>**

![KakaoTalk_20250829_201225441](https://github.com/user-attachments/assets/d13b597e-f4cb-40f8-bf5d-97bd4492be39)


## 12.3 기본 인증의 보안 결함

1. 기본 인증의 base-64 인코딩된 비밀번호는 쉽게 디코딩할 수 있다. → 모든 HTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나 보안이 강화된 프로토콜(다이제스트 인증 등)을 사용하는 것이 좋음
2. 비밀번호가 디코딩하기 복잡하더라도 읽기 힘든 사용자 이름과 비밀번호를 캡쳐한 다음 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다. 기본 인증은 이러한 재전송 공격 예방에 대한 지원이 없다.
3. 기본 인증이 보안에 치명적이지 않은 애플리케이션에 사용되더라도, 일반 사용자들의 웹 사용 행태를 고려하면 굉장히 위험하다. 일반 사용자는 모든 사이트에 같은 아이디와 비밀번호를 사용하는 경우가 많다. 공격자는 이곳에서 얻은 동일한 정보로 중요한 사이트에 접근할 수 있다.
4. 메시지의 인증 헤더는 안 건드리지만 그 외 다른 부분을 수정해서 트랜잭션의 원래 의도를 바꾸는 프락시/중개자가 개입하는 경우 기본 인증은 정상 동작을 보장하지 않는다.
5. 기본 인증은 가짜 서버의 위장에 취약하다. 공격자는 가짜 서버로 사용자에게 비밀번호를 요청하고 저장한다.

기본 인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(SSL 등)과 함께 연계해서 사용할 수 있다.
