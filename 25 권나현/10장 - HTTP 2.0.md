# 10장 - HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷: 구현의 단순성, 접근성에 주안점 두고 최적화 → 성능 희생됨

메시지 교환 방식: 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받음, 단순하지만 심각한 회전 지연 발생 → 병렬 커넥션/파이프라인 커넥션 도입, but 성능에 대한 근본적 해결책은 되지 못함

성능 개선: 구글의 SPDY 프로토콜을 기반으로 HTTP/2.0 프로토콜이 설계됨.

## 10.2 개요

HTTP/2.0: 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작 (TCP 커넥션 초기화 주체: 클라이언트)

- 요청과 응답: 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담김. HTTP 헤더는 압축되어 담김.

프레임에 담긴 요청과 응답은 스트림을 통해 보내짐 → 한 개의 스트림이 한 쌍의 요청과 응답 처리

- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답 동시 처리 가능
- 이들 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공
- 서버 푸시: HTTP/2.0에서 도입된 기존의 요청-응답과는 약간 다른 새로운 상호작용 모델.  이를 통해 서버는 클라이언트에게 필요하다고 생각하는 리소스를 명시적 요청 없이도 능동적으로 보낼 수 있음.
- 요청과 응답 메시지 의미: HTTP/1.1과 같도록 유지(기존 웹 애플리케이션들과 호환성 유지), 표현 문법 변경
    - Content-Length 헤더(본문의 길이) → ‘:content-length’로 변경
    - 404 Not Found 응답(리소스를 찾을 수 없음) → ‘404’ 값을 갖는 ‘:status’ 헤더로 변경

## 10.3 HTTP/1.1과의 차이점

### 프레임

HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송

구조: 모든 프레임은 8바이트 크기의 헤더로 시작하며 최대 16383 크기의 페이로드가 뒤따름

<img width="998" height="446" alt="image" src="https://github.com/user-attachments/assets/e16783b8-376e-4797-a840-bf494bc94f30" />


**<스트림 헤더의 각 필드>**

- R: 예약된 2비트 필드. 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다. 받는 쪽에서는 이 값을 무시해야 함.
- 길이: 페이로드의 길이를 나타내는 14비트 무부호 정수. 이 길이에 프레임 헤더는 미포함
- 종류: 프레임의 종류.
- 플래그: 8비트 플래그. 플래그 값의 의미는 프레임의 종류에 따라 다름
- R: 예약된 1비트 필드. 첫 번째 R과 마찬가지.
- 스트림 식별자: 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임을 의미

HTTP/2.0은 총 10가지 프레임을 정의하고 있으며 페이로드의 형식/내용은 프레임의 종류에 따라 다름.

(DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION)

### 스트림과 멀티플렉싱

**스트림**: HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스

한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어짐

클라이언트는 새 스트림을 만들어 그에 대해 HTTP 요청을 보냄 → 요청 받은 서버는 그 요청과 같은 스트림으로 응답 보냄 → 스트림 닫힘

**HTTP/1.1**: 한 TCP 커넥션을 통해 요청 보냈을 때 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청 보낼 수 있음 → 웹브라우저: 회전 지연 줄이기 위해 여러 개의 TCP 커넥션 만들어 동시에 여러 개의 요청 보내는 방법 사용, but 그렇다고 TCP 커넥션을 무한정 만들 수는 없음 → 오늘날(한 페이지에 보낼 요청이 수십에서 수백에 달함)에는 회전 지연 불가피함, 파이프라인 커넥션을 통해 이를 피할 수 있으나 널리 구현되어 있지 않음

**HTTP/2.0에서의 개선**: 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있음 → 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있음 (문제 해결)

**스트림의 우선순위**: 스트림은 우선순위 가질 수 있으나 우선순위에 따르는 건 의무사항이 아니기 때문에 요청이 우선순위대로 처리된다는 보장은 없음

예) 사용자가 웹브라우저로 어떤 웹페이지를 보려고 할 때, 네트워크 대역폭이 충분하지 않아 프레임의 전송 느림 → 웹브라우저는 보다 중요한 리소스를 요청하는 스트림에게 더 높은 우선순위 부여(이미지 < HTML 페이지)

**스트림의 식별자**: 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 가짐. 

스트림이 클라이언트에 의해 초기화됨: 홀수 식별자, 서버에 의해:  짝수 식별자

새로 만들어지는 스트림의 식별자 > 이전에 만들어졌거나 예약된 스트림들의 식별자

이 규칙을 어기는 식별자를 받았다면 에러 코드가 PROTOCOL_ERROR인 커넥션 에러로 응답

**서버와 클라이언트**: 스트림을 상대방과 협상 없이 일방적으로 만듦 → 스트림을 만들 때 협상 위해 TCP 패킷을 주고받느라 시간 낭비하지 않아도 됨

**재사용**: HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없음. 커넥션을 오래 사용 시 발생하는 스트림 할당 식별자 고갈 현상 발생 → 커넥션 다시 맺기

**우려**: 동시에 여러 개의 스트림을 사용하면 스트림이 블록될 우려 → HTTP/2.0: WINDOW_UPDATE 프레임을 이용한 흐름 제어를 통해 스트림들이 서로 간섭해서 망가지는 현상을 막음

### 헤더 압축

**HTTP/1.1에서 헤더**: 아무런 압축 없이 그대로 전송됨 → 과거와 달리 수십~수백 번의 요청을 보내는 현재 헤더의 크기가 회전 지연과 대역폭 모두에 영향을 끼치게 됨

개선: HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송됨. 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원

**헤더 압축과 해제**

HPACK은 헤더를 압축하고 해제할 때 ‘압축 콘텍스트’를 사용 → 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야 함. 압축 콘텍스트는 수신한 헤더의 압축을 풀면 이에 영향 받아 바뀜. 

송신 측은 수신 측이 헤더의 압축을 풀었으며 그에 따라 압축 콘텍스트가 변경되었다고 가정 → 헤더를 받은 수신 측은 어떤 경우에도 반드시 압축 해제를 수행해야 함. 그럴 수 없다면 반드시 COMPRESSION_ERROR 와 함께 커넥션 끊어야 함.

### 서버 푸시

**HTTP/2.0**: 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 함. → 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용

(HTML 요청 → 이미지, CSS파일, 자바스크립트 파일 푸시 → 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하는 트래픽과 회전 지연을 줄임)

**서버 푸시 과정**: 리소스 푸시 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려줌 → 클라이언트가 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에서는 ‘예약됨(원격)’ 상태가 됨 → 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절 가능 → RST_STREAM을 보내면 그 스트림은 즉시 닫힘. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안 됨.

사전에 PUSH_PROMISE 프레임을 먼저 보내는 이유: 서버가 푸시하려고 하는 자원을 클라이언트가 별도로 또 요청하게 되는 상황 피하기 위함

**<서버 푸시 사용 시 주의점>**

- 서버 푸시를 사용하기로 했더라도 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달 안 할 수도 있음, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수도 있음
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 함. 서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 통해 만들어진 스트림을 통해 보내짐
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 함
- 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH를 0으로 설정

## 10.4 알려진 보안 이슈

### 중개자 캡슐화 공격

HTTP/2.0 메시지를 중간의 프락시(중개자)가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있음. (HTTP/1.1 → HTTP/2.0 번역 과정에서는 발생 X)

 HTTP/1.1과 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩함 → 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 함 → 정상적인 HTTP/2.0 요청이나 응답이 불법적이거나 위조된 HTTP/1.1 메시지로 번역됨을 유발

### 긴 커넥션 유지로 인한 개인정보 누출 우려

HTTP/2.0은 사용자가 요청 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 둠 → 개인 정보의 유출 악용 가능성

예) 어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성도 있음 → HTTP가 현재 갖고 있는 문제이지만 짧게 유지되는 커넥션에서는 위험 적음
