## 8.1 게이트웨이

게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스. 모든 리소스를 한 애플리케이션으로만 처리할 수 없다는 문제에 대한 해결책이며 리소스와 애플리케이션을 연결하는 역할을 함.

애플리케이션: 게이트웨이에 요청 처리를 요청, 게이트웨이: 그에 응답

게이트웨이는 요청을 받고 응답을 보내는 포털처럼 동작 → 동적인 콘텐츠 생성 or 데이터베이스에 질의 보냄

게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환 → HTTP 클라이언트가 다른 프로토콜 알 필요 없이 서버 접속 가능하게 함

### 클라이언트 측 게이트웨이와 서버 측 게이트웨이

웹 게이트웨이: 한쪽에선 HTTP로 통신하고 다른 한쪽에선 HTTP가 아닌 다른 프로토콜로 통신

게이트웨이: 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로  구분

- 서버 측 게이트웨이: 클라이언트와 HTTP로 통신, 서버와는 외래 프로토콜로 통신
- 클라이언트 측 게이트웨이: 클라이언트와 외래 프로토콜로 통신, 서버와는 HTTP로 통신

## 8.2 프로토콜 게이트웨이

게이트웨이에 HTTP 트래픽을 바로 보내는 법: 브라우저에 명시적으로 게이트웨이 설정하여 자연스럽게 트래픽이 게이트웨이 거쳐가게 하기 or 게이트웨이를 대리서버(리버스 프락시)로 설정하기

게이트웨이 설정 → 일반적인 HTTP 트래픽에는 영향 X, 브라우저는 일반 HTTP 트래픽은 원 서버로 바로 보내나 FTP URL을 포함한 요청은 게이트웨이로 HTTP 요청 보냄 → 게이트웨이는 클라이언트 측 요청을 FTP 요청으로 변환하여 처리 → 클라이언트에게 결과 HTTP로 전송

### HTTP/*: 서버 측 웹 게이트웨이

USER와 PASS 명령 보내 서버에 로그인

서버에서 적절한 디렉터리로 변경하기 위해CWD 명령 내림

다운로드 형식을 ASCII로 설정

MDTM으로 문서의 최근 수정 시간 가져온

PASV로 서버에게 수동형 데이터 검색 하겠다고 말함

RETR로 객체 검색

제어 채널에서 반환된 포트로 FTP 서버에 데이터 커넥션 맺음 

### HTTP/HTTPS: 서버 측 보안 게이트웨이

사용: 기업 내부의 모든 웹 요청을 암호화함으로써 개인정보 보호와 보안 제공

클라이언트: 일반 HTTP를 사용하여 웹 탐색

게이트웨이: 자동으로 사용자의 모든 세션 암호화

### HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

웹서버의 앞단에 위치, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할

보안 HTTPS 트래픽 받아서 복호화, 웹서버로 보낼 일반 HTTP 요청 만듦

원 서버보다 효율적으로 보안 트래픽 복호화하느 암호화 하드웨어 내장해서 원 서버 부하 줄이기도 함

## 8.3 리소스 게이트웨이

애플리케이션 서버: 목적지 서버와 게이트웨이를 한 개의 서버로 결합, HTTP 통해 클라이언트와 통신하고 서버 측 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이.

### 공용 게이트웨이 인터페이스(CGI)

최초의 서버 확장이자 가장 널리 쓰이는 서버 확장. 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등 제공

CGI가 서버와 분리되면서 수많은 언어로 구현할 수 있게 됨, 단순하므로 거의 모든 HTTP 서버가 지원함

내부에서 어떤 처리 하는지 사용자에게 보이지 않음, 서버와 CGI애플리케이션 간 진행되는 처리 단계 감춤(클라이언트의 유일한 단서: URL의 ‘cgi’ or ‘?’ 등)

거의 모든 리소스 형식과 서버의 점점에 있으면서 필요에 따라 어떤 변형이든 처리하는 단순한 기능 제공

장점: 문제 많은 확장으로부터 서버 보호

단점: 이런 분리 때문에 성능비용 발생 → Fast CGI 개발(성능저하 해결)

### 서버 확장 API

필요: 서버 자체의 동작 바꾸기, 서버의 처리능력 끌어올리기

서버 개발자: 웹 개발자가 자신의 모듈을 HTTP와 직접 연결 가능한 서버 확장 API 제공. 프로그래머가 자신 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체 가능

유명한 서버 대부분은 개발자에게 확장 API를 한 개 이상 제공

예: 마이크로소프트의 프론트페이지 서버 확장 

## 8.4 애플리케이션 인터페이스와 웹 서비스

애플리케이션이 상호운용 하다보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보 교환해야 함

인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발함 → 웹 서비스(애플리케이션이 정보 공유하는 새로운 매커니즘, HTTP 등의 표준 웹 기술 위에서 개발)

웹 서비스: SOAP을 통해 XML(데이터 객체 담는 데이터 생성/해석 방식)을 사용하여 정보 교환

## 8.5 터널

웹 터널: HTTP 프로토콜 지원 안하는 애플리케이션에 HTTP 애플리케이션 사용해 접근하는 방법

HTTP 커넥션 통해 HTTP가 아닌 트래픽 전송 가능, 다른 프로토코을 HTTP 위에 올리기 가능

### CONNECT로 HTTP 터널 커넥션 맺기

CONNECT 요청: 문법은 시작줄 제외하고는 다른 HTTP 메서드와 같음. 요청 URL은 호스트명이 대신하며 콜론에 이어 포트 기술. 시작줄 다음에는 다른 HTTP 메시지와 같이 추가적인 HTTP 요청 헤더 필드가 있거나 없음. 각 행은 CRLF로 끝남, 헤더 목록의 끝은 빈 줄의 CRLF로 끝남

CONNECT 응답: 클라이언트는 요청 전송하고 게이트웨이의 응답 기다림. 응답에 있는 사유구절은 ‘Connection Established’로 기술. Content-Type 헤더 포함할 필요 없음

### 데이터 터널링, 시간, 커넥션 관리

터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없음 → 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 불가능. 터널이 일단 연결되면 데이터는 언제 어디로든 흘러가버릴 수 있음

클라이언트: 성능 높이기 위해 CONNECT 요청 보낸 다음 응답 받기 전에 터널 데이터 전송 가능

게이트웨이: 커넥션 맺어지는 대로 헤더 포함해서 읽은 모든 데이터를 서버에 전송해야 함

요청 후: 클라이언트는 인증요구나 200 외의 응답이 왔을 때 요청 데이터 다시 보낼 준비 돼 있어야 함

커넥션 끊어지면: 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달됨 → 커넥션 끊어졌던 터널 끝단 반대편의 커넥션도 프락시에 의해 끊어짐, 아직 전송 안한 데이터 버려짐

### SSL 터널링

터널을 사용한다면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있음

SSL 트래픽이 기존 프락시 방화벽 통과 가능하도록 HTTP에 터널링 기능이 추가됨 (HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널 통해 데이터 전송)

HTTP가 아닌 트래픽이 포트 제한하는 방화벽을 통과 가능하게 해주는 터널의 기능은 보안 SSL 트래픽이 방화벽 통과하는 데 유용하게 사용됨. 하지만 터널은 악의적인 트래픽이 사내로 유입되는 경로 될 수도 있음.

### SSL 터널링 vs HTTP/HTTPS 게이트웨이

원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식. 응답은 프락시가 받아서 복호화한 후에 HTTP를 통해 클라이언트로 전송.

단점

- 클라이언트-게이트웨이 사이에서는 보안 적용 안된 일반 HTTP 커넥션이 맺어져 있음
- 프락시가 인증 담당 → 클라이언트는 원격 서버에 SSL 클라이언트 인증 불가능
- 게이트웨이는 SSL 완벽히 지원해야 함

### 터널 인증

HTTP의 다른 기능들은 터널과 함께 사용되는데, 특히 프락시 인증 기능은 클라이언트가 터널 사용할 수 있는 권함 검사 용도로 터널에서 사용

### 터널 보안에 대한 고려사항

터널 게이트웨이는 통신하는 프로토콜이 터널을 올바른 용도로 사용하는지 검증할 방법 없음

오용 최소화하기 위해 게이트웨이는 HTTPS 전용 포트인 443같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함

## 8.6 릴레이

HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시.

커넥션 맺기 위한 HTTP 통신 한 다음 바이트를 맹목적으로 전달.

HTTP는 복잡하기에 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽 전달하는 간단한 프락시 구현하는 방식이 유용할 때가 있음.

데이터의 맹목적 구현: 쉽기 때문에 단순 필터링/진단/콘텐츠 변환하는데도 사용, but 잠재적 심각한 상호 운용 문제 → 주의해서 배포해야 함

문제: 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해 keep-alive 커넥션이 행(hang)에 걸리는 것.

특정 목적 위해서 단순한 HTTP 릴레이 구축한다면 그걸 어떻게 사용할지 신중히 고민해야 함. HTTP 준수하는 프락시 사용하는 게 좋음.
