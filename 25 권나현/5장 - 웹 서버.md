## 5.1 다채로운 웹 서버

웹 서버: HTTP 및 그와 관련된 TCP 처리를 구현한 것으로,

리소스 관리, HTTP 요청 처리와 응답을 제공함. 

소프트웨어와 하드웨어 모두를 가리킴.

다양한 기능, 형태, 크기: 다목적 소프트웨어 웹 서버, 임베디드 웹 서버

## 5.2 간단한 펄 웹 서버

펄 웹 서버: 30줄 이하의 펄 코드로 만들어진 최소한으로 기능하는 HTTP 서버

type-o-serve 펄 프로그램: 클라이언트와 프락시 간의 상호작용 테스트에 유용한 예제용 진단 툴. 

HTTP 요청 메시지를 정확하게 기록하고 응답 메시지를 돌려보냄.

(HTTP 커넥션 기다림 → 요청 메시지 받자마자 화면에 출력 → 응답 메시지 기다림)

## 5.3 진짜 웹 서버가 하는 일

### 웹 서버의 기본 작업

<img width="256" height="197" alt="image" src="https://github.com/user-attachments/assets/52208d63-653e-40da-a467-66a6bcab38cf" />

1. 커넥션 맺기: 클라이언트의 접속 받아들이거나 닫음
2. 요청 받기: HTTP 요청 메시지를 네트워크로부터 읽어들임
3. 요청 처리: 요청 메시지를 해석하고 행동 취함
4. 리소스 접근: 메시지에서 지정한 리소스에 접근
5. 응답 생성: 올바른 헤더를 포함한 HTTP 응답 메시지 생성
6. 응답 보냄: 응답을 클라이언트에게 돌려줌
7. 트랜잭션을 로그로 남김: 로그파일에 트랜잭션 완료에 대한 기록 

## 5.4 단계 1: 클라이언트 커넥션 수락

### 새 커넥션 다루기

클라이언트가 서버에 대해 열려 있는 지속적 커넥션을 가지고 있지 않다면 새 커넥션을 연다.

1. 클라이언트 → 웹 서버: TCP 커넥션을 요청
2. 웹 서버: 그 커넥션 맺고 TCP 커넥션에서 IP주소 추출 (어떤 클라이언트인지 확인)
3. 웹 서버: 새 커넥션을 커넥션 목록에 추가, 데이터 지켜보기 위한 준비

웹 서버: 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있음. (IP주소,&호스트명 인가X, 악의적인 경우)

### 클라이언트 호스트 명 식별

웹 서버(대부분): 클라이언트 IP주소 → 호스트명 변환할 때 역방향 DNS 사용

웹 서버는 클라이언트 호스트 명을 사용할 수 있지만(구체적인 접근 제어, 로깅)

호스트 명 룩업은 꽤 시간이 많이 걸려 웹 트랜잭션을 느려지게 함.

그래서 많은 대용량 웹 서버는 호스트 명 분석을 꺼두는 편.

### ident(사용자 알아내기)

ident 프로토콜: 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해줌. (웹 서버 로깅에서 유용)

<ident가 공공 인터넷에서 잘 동작하지 않는 이유>

- 많은 클라이언트 PC는 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않음
- ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킴
- 방화벽이 ident 트래픽이 들어오는 것을 막는 경우 많음
- ident 프로토콜은 안전하지 않고 조작하기 쉬움, 가상 IP 주소를 잘 지원하지 않음
- 클라이언트 사용자 이름의 노출(프라이버시 침해)

## 5.5 단계 2: 요청 메시지 수신

커넥션에 데이터가 도착하면 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어들이고 파싱하여 요청 메시지를 구성함.

<요청 메시지 파싱할 때 웹 서버가 하는 일>

- 요청줄 파싱 → 요청 메서드, 저장된 리소스의 식별자, 버전 번호 찾기 (스페이스 하나로 분리)
- 메시지 헤더들 읽기 (CRLF로 끝남)
- 헤더의 끝 찾기(CRLF로 끝나는 빈 줄)
- 요청 본문이 있다면 읽어들이기

### 메시지의 내부 표현

몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장함.

### 커넥션 입력/출력 처리 아키텍처

<img width="238" height="212" alt="image" src="https://github.com/user-attachments/assets/fd77fb03-adb1-47f7-9f94-2994a3e52f74" />

1. 단일 스레드 웹 서버: 한 번에 하나씩 요청 처리→ 심각한 성능 문제(진단도구에서만 쓰임)
2. 멀티프로세스와 멀티스레드 웹 서버: 여러 요청 동시에 처리(고효율 스레드, 낭비 → 최대 개수 제한)
3. 다중 I/O 서버: 모든 커넥션이 동시에 활동 감시당함, 처리 완료되면 열린 커넥션 목록으로 이동 (커넥션에 해야 할 일이 있을 때만 작업 수행하므로 리소스 낭비 X)
4. 다중 멀티스레드 웹 서버: 멀티스레드와 다중화의 결합, 여러 개의 스레드가 각각 작업 수행

## 5.6 단계 3: 요청 처리

웹 서버가 요청을 받으면 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어내어 처리함.

(본문 요구: POST, 본문 요구X: 그 외 다수의 메서드, 본문 금지: GET)

## 5.7 단계 4: 리소스의 매핑과 접근

웹 서버: 리소스 서버로, 정적 콘텐츠(HTML, JPEG 등)와 동적 콘텐츠(리소스 생성 애플리케이션으로 만들어짐) 제공

웹 서버의 클라이언트로의 콘텐츠 전달: 요청 메시지의 URI에 대응하는 알맞은 콘텐츠를 웹 서버에서 찾아 원천 식별해야 함.

### Docroot

docroot: 리소스 매핑(요청 URI를 파일 이름으로 사용) 시 웹 콘텐츠를 위해 예약해두는 웹 서버 파일 시스템의 특별한 폴더.

가상 호스팅된 docroot: 하나의 웹 서버에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅. 서버는 두 웹 사이트를 HTTP Host 헤더나 서로 다른 IP 주소를 이용해 구분.

(가상 호스팅 웹 서버: 웹 서버에서 여러 개의 웹 사이트 호스팅)

사용자 홈 디렉터리 docroot: 사용자들이 한 대의 웹 서버에서 각자의 개인 웹 사이트를 만들 수 있도록 하는 것.

### 디렉터리 목록

<클라이언트가 디렉터리 URL을 요청했을 때 웹 서버의 행동>

- 에러 반환
- 디렉터리 대신 특별한 색인 파일 반환
- 디렉터리 탐색 → 그 내용 담은 HTML 페이지 반환

### 동적 콘텐츠 리소스 매핑

요청에 맞게 콘텐츠 생성하는 프로그램(동적 리소스)에 URI 매핑

대부분의 웹 서버는 동적 리소스를 식별하고 매핑할 수 있는 기본적인 메커니즘을 가짐. 

### 서버사이드 인클루드

만약 어떤 리소스가 서버사이드 인클루드를 포함하면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리함.

### 접근 제어

웹 서버: 각각의 리소스에 접근 제어 할당 가능

## 5.8 단계 5: 응답 만들기

### 응답 엔터티

트랜잭션이 응답 본문을 생성한다면 그 내용을 응답 메시지와 함께 돌려보냄.

<응답 메시지의 구성>

- 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 실제 응답 본문의 내용

### MIME 타입 결정

웹 서버는 응답 본문의 MIME 타입을 결정해야 함.

<MIME 타입과 리소스를 연결하는 방법들>

- mime.types: 확장자 기반 타입 연계
- 매직 타이핑: 파일 내용 검사
- 유형 명시: 파일 확장자나 내용에 상관없는 타입 갖도록 설정
- 유형 협상: 한 리소스가 여러 종류의 문서 형식에 속하도록 설정

### 리다이렉션

웹 서버는 성공 메시지 대신 리다이렉션 응답을 반환하기도 함.

요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트할 수 있음.

<리다이렉트가 유용한 경우>

- 영구히 리소스가 옮겨진 경우 (301)
- 임시로 리소스가 옮겨진 경우 (303, 307)
- URL 증강 (303, 307)
- 부하 균형 (303, 307)
- 친밀한 다른 서버가 있을 때(303, 307)
- 디렉터리 이름 정규화

## 5.9 단계 6: 응답 보내기

여러 클라이언트에 대한 많은 커넥션을 가질 수 있는 서버는 커넥션들의 상태를 추적해야 하며

지속적인 커넥션은 특별히 주의해서 다뤄야 함. (열린 상태 유지: Content-Length 헤더의 바른 계산, 특별한 주의 필요, 응답 종료 시점 알 수 없는 경우)

(비지속적인 커넥션: 서버가 모든 메시지 전송하면 닫음)

## 5.10 단계 7: 로깅

트랜잭션이 완료되었을 때 웹 서버: 트랜잭션이 어떻게 수행됐는지에 대한 로그를 로그파일에 기록
