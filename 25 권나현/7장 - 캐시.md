웹 캐시: 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치.

웹 요청이 캐시에 도착했을 때 캐시된 로컬 사본이 존재한다면 → 그 문서는 원 서버가 아닌 그 캐시로부터 제공됨

**<캐시의 효과>**

- 불필요한 데이터 전송을 줄여 네트워크 요금을 줄임
- 네트워크 병목을 줄임 (대역폭 늘리지 않고도 페이지 빠르게 불러오기)
- 원 서버에 대한 요청 줄임 → 서버 부하 줄어듦, 빠른 응답 가능
- 거리로 인한 지연 줄어듦 (먼 곳에서 불러올수록 시간 많이 걸림)

## 7.1 불필요한 데이터 전송

**불필요한 데이터 전송이란**

여러 클라이언트가 자주 쓰이는 원  서버 페이지에 접근 → 서버는 같은 문서를 클라이언트 각각에게 전송 → 똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동 → 비싼 네트워크 대역폭 차지, 느린 전송, 웹 서버 부하

**캐시를 이용한다면**

서버 응답은 캐시에 보관됨 → 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용됨 → 원 서버의 중복된 트래픽 낭비 줄어듦

## 7.2 대역폭 병목

많은 네트워크는 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭 제공

클라이언트가 빠른 LAN에 있는 캐시로부터 사본 가져온다면 → 캐싱 성능 개선 

## 7.3 갑작스런 요청 쇄도

캐싱은 갑작스런 요청 쇄도 대처에 중요함.

(갑작스런 사건으로 많은 사람이 동시에 웹 문서 접근 → 불필요한 트래픽 급증 초래 → 웹 서버 장애 야기)

## 7.4 거리로 인한 지연

대역폭이 문제가 아니라도 거리가 문제일 수 있음. 

인터넷 트래픽 지연 요소: 네트워크 라우터, 빛의 속도

## 7.5 적중과 부적중

캐시가 모든 문서의 사본을 저장하는 것은 아님.

캐시 적중: 캐시에 요청이 도착했을 때 그에 대응하는 사본이 있다면 그를 이용해 요청 처리

캐시 부적중: 캐시에 요청에 대응하는 사본이 없다면 원 서버로 전달되기만 함

### 재검사

HTTP 재검사: 캐시가 자신이 가지고 있는 사본이 변경되지 않은 최신인지 서버를 통해 하는 점검

재검사의 조건: 사본이 검사를 할 필요가 있을 정도로 오래된 경우 (네트워크 대역폭 부족하기 때문)

재검사 과정

1. 캐시된 사본의 재검사가 필요한 캐시는 원 서버에 작은 재검사 요청을 보냄
2. 콘텐츠가 변경되지 않았다면 서버는 작은 304 응답을 보냄
3. 그걸 받은 캐시는 사본의 유효함을 임시로 다시 표시한 뒤 사본을 클라이언트에 제공 

→ 재검사 적중/느린 적중: 순수 캐시 적중보다 느림(원 서버와 검사해야 하기 때문), 캐시 부적중보다 빠름 (서버로부터 객체 데이터를 받아올 필요가 없기 때문)

<img width="1922" height="898" alt="image" src="https://github.com/user-attachments/assets/f22b19a4-a560-4574-8518-b60dfed084b0" />


캐시된 객체 재확인 도구: If-Modified-Since 헤더

서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내라는 의미

**<재검사 적중>**

서버 객체가 변경되지 않았다면 → 서버는 클라이언트에게 작은 304 응답을 보냄

<img width="842" height="438" alt="image" src="https://github.com/user-attachments/assets/b6a33a0c-ee5b-4226-b65a-2201bc82114b" />


**<재검사 부적중>**

서버 객체가 캐시된 사본과 다르다면 → 서버는 콘텐츠 전체와 함께 평범한 200 응답을 보냄

**<객체 삭제>**

서버 객체가 삭제되었다면 → 서버는 404 응답을 돌려보냄, 캐시는 사본 삭제

### 적중률

캐시 적중률(문서 적중률): 캐시가 요청을 처리하는 비율

적중률은 0에서 1까지의 값, 퍼센트로 표현되기도 함.

(0%: 모든 요청이 캐시 부적중, 100%: 모든 요청이 캐시 적중)

실제 적중률은 캐시 크기, 캐시 사용자들의 관심사 유사도, 캐시된 데이터의 변경/개인화 빈도, 캐시 설정 방식에 달려 있음.

적중률 40%면 웹 캐시로 괜찮은 편.

### 바이트 적중률

바이트 단위 적중률 측정값을 선호하는 사람들: 문서들이 모두 같은 크기가 아니기에 문서 적중률이 트래픽의 모든 바이트에 요금 매기기에 어렵다. 몇몇 큰 객체는 덜 접근되지만 크기 때문에 트래픽에는 더 크게 기여하기 때문.

바이트 단위 적중률: 캐시를 통해 제공된 모든 바이트의 비율을 표현. 측정값은 트래픽 절감 정도 포착.

(바이트 단위 적중률 100%: 모든 바이트가 캐시에 있으며 어떤 트래픽도 인터넷으로 나가지 않았음)

**<문서 적중률 vs 바이트 단위 적중률>**

문서 적중률: 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 (전체 대기시간 절감)

바이트 단위 적중률: 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 (대역폭 절약 최적화)

### 적중vs부적중

HTTP는 클라이언트에게 응답이 캐시 적중이었는지 캐시 부적중(원 서버 접근)인지 말해주는 방법 제공하지 않음.

(두 경우 모두 응답 코드: 200 OK-응답이 본문 갖고 있음)

어떤 상용 프락시 캐시는 캐시에 일어난 일을 설명하기 위해 Via 헤더에 추가 정보 붙임.

클라이언트에서 응답이 캐시에서 왔는지 알아내는 방법: Date 헤더 이용, Age 헤더 이용

Date 헤더 이용: 응답의 Date 헤더 값을 현재 시각과 비교하여 응답의 생성일이 더 오래되었다면 응답이 캐시된 것.

Age 헤더 이용: 응답이 얼마나 오래되었는지 말해줌

## 7.6 캐시 토폴로지

개인 전용 캐시: 한 명에게만 할당된 캐시. 한 명의 사용자가 자주 찾는 페이지를 담음.

공용 캐시: 공유된 캐시. 사용자 집단에게 자주 쓰이는 페이지를 담음.

### 개인 전용 캐시

비용: 작고 저렴함 (많은 에너지나 저장 공간이 필요하지 않음)

웹브라우저는 개인 전용 캐시를 내장하고 있음.

대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가캐시 사이즈와 설정을 수정할 수 있도록 허용함.

캐시에 들어있는 내용 확인 방법(구글 크롬): about:cache로 연결되는 페이지 → 캐시 컨텐츠 목록

### 공용 프락시 캐시

공용 캐시: 캐시 프락시 서버/프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버

(로컬 캐시에서 문서 제공, 사용자 입장에서 서버 접근)

공용 캐시는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 많은 기회 존재

<img width="1930" height="1532" alt="image" src="https://github.com/user-attachments/assets/6bed238a-d381-4597-95c0-682516c1c554" />


프락시를 위한 규칙: 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정 → 브라우저가 프락시 캐시를 사용하도록 설정할 수 있음.

### 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 남겨진 트래픽을 처리하는 계층을 만드는 방식이 합리적임. → 클라이언트 주위: 작고 저렴한 캐시, 계층 상단: 크고 강력한 캐시 (많은 사용자들에 의해 공유되는 문서 유지)

<img width="1932" height="1422" alt="image" src="https://github.com/user-attachments/assets/499f5b23-5c6f-4fda-a466-b21db7280e46" />


사용자와 가까운 1단계 캐시에서 적중이 안된다면 더 큰 부모 캐시가 사용자의 요청 처리

그러나 캐시 계층이 깊다면 → 요청은 캐시의 긴 연쇄를 따라가게 될 것 → 프락시 연쇄가 길어질수록 각 중간 프락시의 성능 저하 

### 캐시망, 콘텐츠 라우팅, 피어링

네트워크 아키텍처가 단순한 캐시 계층 대신 복잡한 캐시망을 이루는 경우: 캐시망의 프락시 캐시는 서로 대화하여 캐시 커뮤니케이션 결정(어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 우회해 원 서버로 가도록 할 것인지)을 동적으로 내림

**<캐시망 안 콘텐츠 라우팅을 위한 캐시의 기능>**

- URL에 근거하여 부모 캐시와 원 서버 하나를 동적으로 선택
- URL에 근거하여 특정 부모 캐시를 동적으로 선택
- 부모 캐시에게 가기 전에 캐시된 사본을 로컬에서 탐색
- 다른 캐시들의 그들의 캐시된 콘텐츠에 대한 부분적 접근 허용, 반면 그들의 캐시를 통한 인터넷 트랜짓은 허용X (왜?)

형재 캐시: 선택적인 피어링을 지원하는 캐시

<img width="819" height="561" alt="image" src="https://github.com/user-attachments/assets/b3e54014-c638-4cd3-881b-b79a12cd7028" />


HTTP는 형제 캐시를 지원하지 않음 → ICP(인터넷 캐시 프로토콜)나 HTCP(하이퍼텍스트 캐시 프로토콜) 이용해 HTTP 확장

## 7.7 캐시 처리 단계

HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 7단계로 이루어짐.

(요청 받기 → 파싱 → 검색 → 신선도 검사 → 응답 생성 → 발송 → 로깅)

<img width="842" height="594" alt="image" src="https://github.com/user-attachments/assets/e553b3ae-1660-4005-8733-df398d5a6dc2" />


### 단계 1: 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들임

(고성능 캐시는 여러 개의 커넥션으로부터 데이터 동시에 읽어들이고 메시지 전체가 도착하기 전에 드랜잭션 처리 시작)

### 단계 2: 파싱

캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담음

이는 캐싱 소프트웨어가 헤더 필드의 처리, 조작을 쉽게 함

### 단계 3: 검색

캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사함

로컬 복사본은 메모리에 저장되어 있을 수도 있고, 디스크나 근처의 다른 컴퓨터에 있을 수도 있음

(전문적인 수준의 캐시: 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘 사용)

문서를 로컬에서 가져올 수 없다면:

캐시는 상황이나 설정에 따라 그것을 원 서버/부모 프락시에서 가져오거나 실패 반환

캐시된 객체는 서버 응답 본문+원 서버 응답 헤더 포함→ 캐시 적중 동안 올바른 서버 헤더 반환 가능

(+ 캐시된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지 알려주는 기록/얼마나 자주 사용되었는지 등에 대한 메타데이터를 포함함)

### 단계 4: 신선도 검사

HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해줌

이 기간 동안 문서는 신선한 것으로 간주, 캐시는 서버와의 접촉 없이 문서 제공 가능

but 캐시된 사본을 신선도 한계를 넘을 정도로 오래 보관 → 그 객체는 신선하지 않은 것으로 간주 → 캐시는 문서 제공 전에 서버와 재검사 필요

HTTP의 신선도 검사 규칙은 매우 복잡함

### 단계 5: 응답 생성

캐시는 캐시된 서버 응답 헤더를 기반으로 응답 헤더를 생성함.

이 기저 헤더들은 캐시에 의해 수정되고 늘어남.

캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있음. 캐시는 또한 캐시 신선도 정보를 삽입하고, 요청이 프락시 캐시를 거쳐갔음을 알려주는 Via 헤더를 포함시킴.

주의: 캐시가 Date 헤더를 조정해서는 안 됨. (Date 헤더: 객체가 원 서버에서 최초로 생겨난 일시 표시)

### 단계 6: 전송

응답 헤더 준비됨 → 캐시는 응답을 클라이언트에게 돌려줌

모든 프락시 서버들과 마찬가지로 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음

(고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력)

### 단계 7: 로깅

대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지함.

각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 계수에 대한 통계를 갱신하고

로그 파일에 요청 종류, URL, 무엇이 일어났는지를 알려주는 항목을 추가함

가장 많이 쓰이는 캐시 로그 포맷: 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷

많은 캐시 제품이 커스텀 로그 파일 허용

### 캐시 처리 플로 차트

<img width="747" height="466" alt="image" src="https://github.com/user-attachments/assets/469e4a86-5579-4935-bc65-0b4686c87403" />


## 7.8 사본을 신선하게 유지하기

캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 함.

문서 만료&서버 재검사: 어떤 캐시가 사본을 가지는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지하는 단순한 HTTP 메커니즘

### 문서 만료

Cache-Control, Expires 헤더: 원 서버가 각 문서에 유효기간 붙일 수 있게 함

캐시 문서가 만료되기 전 → 캐시는 필요하다면 서버와의 접촉 없이 사본 제공

캐시된 문서 만료 → 캐시는 반드시 서버와 문서의 변경 여부 검사해야 함, 변경되었다면 신선한 사본을 얻어와야 함(새 유효기간)

### 유효기간과 나이

서버의 유효기간 명시: HTTP/1.0+ Expires, HTTP/1.1 Cache-Control:max-age 응답 헤더

Expires와 Cache-Control:max-age 헤더는 기본적으로 같은 일을 하지만 절대 시간은 컴퓨터의 시계가 올바르게 맞춰져 있을 것을 요구함

<유효기간과 관련된 응답 헤더>

**Cache-Control:max-age**

max-age 값은 문서의 최대 나이를 정의함 (최대 나이: 문서가 처음 생성된 이후부터 제공하기에 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값-초 단위)

Cache-Control: max-age=484200

**Expires**

절대 유효기간을 명시함 (유효기간 경과 시 그 문서는 신선하지 않음)

Expires: Fri, 05 Jul 2002, 05:00 GMT

### 서버 재검사

캐시된 문서가 만료됨 =! 그 문서가 원 서버에 현재 존재하는 것과 실제로 다름

다만 이제 검사할 시간이 되었음을 뜻함

서버 재검사: 캐시가 원 서버에게 문서 변경 여부를 물어볼 필요가 있음

- 재검사 결과 콘텐츠 변경 → 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게 전송
- 재검사 결과 콘텐츠 변경 X → 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신

이는 신선하지 않은 콘텐츠는 제공하지 않으면서도 서버 트래픽을 절약하고 사용자 응답 시간을 개선함.

<HTTP 프로토콜의 캐시 반환 행동 요구>

- 충분히 신선한 캐시된 사본
- 원 서버와 재검사되어 충분히 신선함을 확신하는 캐시된 사본
- 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
- 경고 메시지 부착된 캐시된 사본(부정확 시)

### 조건부 메서드와의 재검사

HTTP의 조검부 메서드는 재검사를 효율적으로 만듦.

HTTP는 다섯 가지 조건부 요청 헤더를 정의하는데, 그 중 유용한 두 가지: If-Modified-Since, If-None-Match

**If-Modified-Since(날짜 재검사)**

문서가 주어진 날짜 이후로 수정되었다면 요청 메서드 처리함. 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 가져오기 위해 Last-Modigied 서버 응답 헤더와 함께 사용

**If-None-Match(엔터티 태그 재검사)**

마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공. 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청 처리

### 약한 검사기와 강한 검사기

엔터티 태그: 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 사용

(엔터티 태그와 최근 변경일시: 캐시 검사기)

강한 검사기는 콘텐츠가 바뀔 때마다 바뀜. 

약한 검사기는 어느 정도 콘텐츠 변경을 허용, but 콘텐츠의 중요한 의미가 변경되면 함께 변경됨

원 서버는 서로 다른 두 엔터티에 대해 강한 엔터티 태그 값을 재활용해서는 안 됨

(약한 엔터티 태그값: 의미 다른 두 엔터티의 경우 재활용 X)

유효기간에 관계없이 캐시 항목은 임의의 긴 기간 동안 계속될 수 있음

### 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

서버가 엔터티 태그를 반환했다면 → 반드시 엔터티 태그 검사기 사용

서버가 Last-Modified 값만을 반환 → 클라이언트는 If-Modified-Since 검사 사용 가능

엔터티 태그와 최근 변경 일시 모두 사용 가능 → 클라이언트는 HTTP/1.0, HTTP/1.1에 대한 재검사정책 모두 사용해야 함

HTTP/1.1 원 서버 → 실현가능한 경우 엔터티 태그 검사기를 보내야 함(Last-Modified값 같이 보내기도)

HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면 → 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 응답을 보내서는 안 됨.

## 7.9 캐시 제어

HTTP는 문서 만료 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정 가능한 여러 가지 방법 제공

- Cache-Control: no store 헤더를 응답에 첨부 가능
- Cache-Control: no cache 헤더를 응답에 첨부 가능
- Cache-Control: must-revalidate 헤더를 응답에 첨부 가능
- Cache-Control: max-age 헤더를 응답에 첨부 가능
- Expires 날짜 헤더를 응답에 첨부 가능
- 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인 방법으로 결정하게 할 수 있음

### no-cache와 no-store 응답 헤더

캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음

no-store: 캐시가 그 응답의 사본을 만드는 것을 금지

no-cache: 사실 로컬 저장소에 저장될 수 있음. 다만 먼저 서버와 재검사 안 하면 캐시에서 클라이언트로 제공 불가능

### Max-Age 응답 헤더

신선하다고 간주됐던 문서가 서버로부터 온 이후로 흐른 시간이며 초로 나타냄

s-maxage 헤더: 공용 캐시에만 적용됨

서버는 maximum aging을 0으로 설정 → 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청 가능

### Expires 응답 헤더

더 이상 사용하지 않기를 권하는 헤더. 초 단위의 시간 대신 실제 만료 날짜를 명시함.

### Must-Revalidate 응답 헤더

캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨.

만약 캐시가 이 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태 → 캐시는 반드시 504를 반환

### 휴리스틱 만료

만약 응답이 어느 것도 포함하지 않다면 캐시는 경험적인 방법으로 최대 나이 계산

어떤 알고리즘이든 사용될 수 있지만, 계산 결과 얻은 최대 나이 값이 24시간보다 크다면 → Heuristic Expiration 경고 헤더가 응답헤더에 추가돼야 함 (이 경고 정보를 사용자가 볼 수 있게 해주는 브라우저는 거의 없음)

**<LM 인자 알고리즘의 로직>**

- 캐시된 문서가 마지막으로 변경된 게 상당히 예전이다 → 아마 안정적인 문서일 거고 갑자기 바뀔 가능성은 크지 않음 → 캐시에 더 오래 보관하고 있어도 안전
- 캐시된 문서가 최근에 변경됨 → 아마 자주 변경될 것 → 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 함

휴리스틱 신선도 계산은 생각보다 흔히 하게 된다.

### 웹클라이언트 신선도 제약

리프레시 버튼: Cache-control 요청 헤더가 추가된 GET 요청을 발생시킴 → 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴

클라이언트는 Cache-Control 요청 헤더를 사용하여 만료 제약을 엄격하거나 느슨하게 할 수 있음

### 주의할 점

문서 만료는 완벽한 시스템이 아님 → 많은 퍼블리셔가 유효기간을 길게 잡지 않음

## 7.10 캐시 제어 설정

### 아파티로 HTTP 헤더 제어하기

mod-headers 모듈: 개별 헤더들을 설정할 수 있게 해줌

mod-expires 모듈: 적절한 만료 날짜가 담긴 Expires 헤더를 자동을 생성하는 프로그램 로직 제공

mod_cern_meta 모듈: HTTP 헤더들의 파일을 특정 객체와 연결시켜줌

### HTTP-EQUIV를 통한 HTML 캐시 제어

문서의 캐시의 동작을 제어하는 서투른 방법.

META HTTP-EQUIV 태그: HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의함.

원래 웹 서버에서 사용되도록 의도된 것.

불행하게도 이 기능을 지원하는 웹 서버나 프락시는 거의 없음.

문서의 캐시 제어 요청과 커뮤니케이션하는 확실한 방법: 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것.

## 7.11 자세한 알고리즘

.

## 7.12 캐시와 광고

### 광고 회사의 딜레마

많은 콘텐츠 제공자가 광고로 돈 버는 게 캐시와 관련되면 문제가 됨.

캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있음.

캐싱이 완벽하게 동작 → 원 서버는 HTTP 접근을전혀 수신하지 않음

접근 횟수에 따라 돈 버는 건 달갑지 않은 일

### 퍼블리셔의 응답

오늘날 광고회사들은 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 캐시 무력화 기법을 사용함.

광고를 CGI 게이트웨이를 통해 제공함. 매 접근마다 광고 URL을 고쳐 씀.

사실 캐시 무력화 기법은 주로 모든 웹브라우저에서 켜져 있는 캐시를 주요 대상으로 함.

이상적: 콘텐츠 제공자는 캐시가 그들의 트래픽을 흡수하도록 내버려 둬야 함, 캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려줘야 함

### 로그 마이그레이션

서버로 요청이 가지 않도록 하면 캐시는 모든 적중의 로그를 유지할 수 있음.

불행히도 적중 로그는 크기 때문에 옮기기 어려움. 캐시 로그는 표준화/조직되어 있지 않음. 인증과 프라이버시 이슈도 있음.

효율적인 로그 재분산 전략이 제안됐지만 충분히 발전된 건 없음.

### 적중 측정과 사용량 제한

RFC 2227: HTTP에 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라는 새 헤더 하나를 추가함. 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 받음

서버:  캐시가 서버에게 보고해야 하기 전까지 문서 제공 가능 횟수, 소모 가능 처리시간을 제어 가능

→ 사용량 제한: 캐시가 원 서버에게 보고하기 전에 캐시된 리소스가 얼마나 많이 사용될 수 있는지 서버가 제어할 수 있게 해줌
