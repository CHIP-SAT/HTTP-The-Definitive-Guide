## 12.1 인증

- 인증은 당신이 누구인지 증명하는 것

## HTTP의 인증요구/응답 프레임워크

### 간략하게 묘사한 인증요구/응답
<img width="930" height="661" alt="image" src="https://github.com/user-attachments/assets/fef7474c-94c3-4c87-ae29-38c972e23853" />

웹 애플리케이션이 HTTP 요청 메시지 받음 → 서버는 요청 처리하는 대신 개인정보를 요구하는 ‘인증요구’로 응답

사용자가 다시 요청 보낼 때는 인증 정보(ID, PW) 첨부해야 함.

인증 정보 OK? 문제 없이 처리
Not OK? 다시 인증요구를 보내거나 에러를 낼수 있음.

## 인증 프로토콜과 헤더
HTTP는 필요에 따라 수정 가능한 제어 헤더를 통해 다른 프로토콜과의 호환을 위한 확장 프레임워크를 제공.

헤더의 형식과 내용은 인증 프로토콜에 따라 다름.

HTTP의 두 가지 공식적 인증 프로토콜: 기본 인증, 다이제스트 인증

**<네 가지 인증 단계>**
<img width="934" height="449" alt="image" src="https://github.com/user-attachments/assets/288a2d76-7cfc-4bbb-9b5a-5af287e41bfc" />


## 보안 영역

웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나누고, 보안 영역은 저마다 다른 사용자 권한을 요구함.

**웹 서버의 보안 영역**
<img width="931" height="334" alt="image" src="https://github.com/user-attachments/assets/3cbf323f-32e2-481e-9b33-1436adfdbf59" />

---

### 12.2 기본 인증

- 기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있음.
- 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 `WWW-Authenticate`에 기술해서 응답하여 인증요구를 시작함.
- 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 `Authorization` 요청 헤더 안에 암호화해서 서버로 다시 전송함.

- **기본 인증 헤더**

  <img width="564" height="452" alt="image" src="https://github.com/user-attachments/assets/30981ece-76d0-4956-89fc-410feeedfb27" />

    - 기본 인증 헤더는 `Authentication-Info` 헤더를 사용하지 않음.
- base-64 인코딩: 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환 → 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택됨.
- 사용자 이름과 비밀번호로 기본 `Authorization` 헤더 생성하기
  <img width="552" height="696" alt="image" src="https://github.com/user-attachments/assets/3984e641-deb8-4f76-8b07-03162eed222d" />

- 어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증함.
    - 웹 서버와 프락시 인증에서 쓰이는 상태 코드와 헤더들의 대조표
      <img width="559" height="329" alt="image" src="https://github.com/user-attachments/assets/4fe9926a-25f7-4014-b499-ba854a0754a2" />


---

### 12.3 기본 인증의 보안 결함

1. base-64로 인코딩된 사용자 이름과 비밀번호는 인코딩 절차를 반대로 수행해서 어렵지 않게 디코딩할 수 있음.
    - 대안 ⇒ 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋음.
2. 제 3자가 사용자 이름과 비밀번호를 캡처하여 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있음.
    - 기본 인증은 재전송 공격을 예방하기 위한 어떤 일도 하지 않음.
3. 메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않음.
4. 기본 인증은 가짜 서버의 위장에 취약함.
    - 만약 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것임.
