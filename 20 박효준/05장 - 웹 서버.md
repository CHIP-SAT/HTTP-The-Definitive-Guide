### 학습 목표
- 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사한다.
- 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 알아본다.

##

### 진짜 웹 서버가 하는 일
서버는 HTTP 요청을 처리하고 응답을 제공한다.

![2025  8  5  16:40 Microsoft Lens](https://github.com/user-attachments/assets/be9b29e9-cbc5-4705-bc8b-360e392438cc)

1. 커넥션을 맺는다, 클라이언트 요청을 받아 들이거나, 원치 않으면 닫음
2. 요청을 받는다, HTTP 요청 메세지를 해석하고 행동을 취함
3. 요청을 처리한다, 요청 메세지를 해석하고 행동을 취함
4. 리소스에 접근한다, 메세지에서 지정한 리소스에 접근함
5. 응답을 만든다, 올바른 헤더를 포함한 HTTP 응답 메세지를 생성함
6. 응답을 보낸다, 응답을 클라이언트에게 돌려줌
7. 트랜잭션 로그를 남긴다, 로그 파일에 트랜잭션 완료에 대한 기록을 남김

<br>

### 1단계 클라이언트 커넥션 수락
클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면, 해당 커넥션을 이용할 수 있다. 그렇지 않으면, 클라이언트는 서버에 대한 새 커넥션을 열 필요가 있다.

클라이언트가 TCP 요청을 하면, 서버는 커넥션을 맺고 TCP 커넥션에서 IP를 추출하여 맞은 편 클라이언트에 대해 확인한다.

이때 역 DNS를 사용하여 클라이언트 IP 주소를 호스트 명으로 바꾸고, 호스ㅡ트 명을 구체적인 접근 제어와 로깅을 위해 사용할 수 있다.

#### ident를 통해 클라이언트 사용자 알아내기
몇몇 웹 서버는 IETF(= 국제 인터넷 표준화 기준) ident 프로토콜을 지원한다. ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션에 초기화했는지 찾아낼 수 있게 해준다. 이게 웹 서버 로깅에서 유용하다.

만약 클라이언트가 ident 프로토콜을 지원한다면, ident 결과를 위해 TCP 포트 113번을 Listen 구독해야 한다.

![2025  8  5  16:46 Microsoft Lens(1)](https://github.com/user-attachments/assets/6f665557-da6a-4a39-868f-d14be1bc2370)

클라이언트가 HTTP 커넥션을 열고, 그 후 자신의 커넥션을 클라이언트의 identd 서버 포트를 향해 열고, 새 커넥션에 대응하는 사용자 이름을 묻는 간단한 요청을 보낸다.

그러나, ident는 조직 내부에선 좋으나, 공공 인터넷에서는 사용하지 않는다. 방화벽이 ident를 막거나, HTTP 트랜잭션을 지연시키거나, 안전하지 않는 등의 문제가 있기 때문이다.

<br>

### 2단계 요청 메세지 수신
커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 데이터를 읽고 파싱하여 요청 메세지를 구성한다.

파싱은 다음과 같이 진행한다.

- 요청 메소드, URI, 버전 번호를 찾는다.
- 메세지 헤더를 읽는다, 이때 각 헤더들은 CRLF로 끝난다.
- 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다.

#### 커넥션 입출력 처리 아키텍처
고성능 웹 서버는 수 천개의 커넥션을 동시에 열도록 지원한다. 그리고 이는 아키텍처 방식에 따라 달라진다.

![2025  8  5  16:53 Microsoft Lens](https://github.com/user-attachments/assets/8e873df3-d32c-46e4-9589-3beed3230e63)

- 단일 스레드: 하나에 하나씩 처리
- 멀티프로세스/멀티스레드: 요청마다 스레드를 할당할 수 있으나, 리소스 소모가 큼
- 다중 IO: 커넥션 상태에 따라 라운드 로빈처럼 사용되는 거 같음
- 다중 멀티스레드: 여러 개의 스레드가 열려있는 커넥션을 감시하고 작업을 수행

<br>

### 3단계 요청 처리
서버는 요청을 받으면 메소드, 리소스, 헤더, 본문을 얻어내어 처리한다.

이건 뒤에서 더 다룸

<br>

### 4단계 리소스의 매핑과 접근
웹 서버는 리소스 서버다. 정적 컨텐츠부터 동적 컨텐츠까지 제공하는데, 서버는 요청 URI에 대해 알맞은 콘텐츠를 찾을 줄 알아야 한다.

#### Docroot
웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해두고, 이것을 docroot라 부른다. 요청 메세지에서 URI를 가져와, 문서루트 뒤에 붙인다.

가상 호스팅 웹 서버는 그들만의 분리된 문서 루트를 주는 방식으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅한다. URI나 Host 헤더에서 얻은 IP주소나 호스트 명이 식별하는데 사용된다.

<br>

### 5단계 응답 만들기
서버가 리소스를 식별하면, 서버는 요청 메소드 동작을 수행하고 응답 메세지를 반환한다.

이때 응답 메세지는 상태코드, 헤더, 본문을 포함해야 한다.

#### 응답 엔티티
트랜잭션이 응답 본문을 생성하면, 함께 돌려보내야 한다.

만약 본문이 있다면 응답 메세지는 다음을 포함한다.

- 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 실제 응답 본문의 내용

#### MIME 타입  결정
서버는 응답 본문의 MIME 타입을 결정해야 하는 책임이 있다.

- mime.types: 파일 이름의 확장자 사용
- 매직 타이핑: 아파치 웹 서버는 파일 내용을 검사해서 패턴에 대해 테이블에서 찾음

#### 리다이렉션
웹 서버는 종종 리다이렉션 응답을 반환한다. 이때 리다이렉트할 경우가 다음과 같이 있다.

- 영구히 리소스가 옮겨진 경우: 클라이언트는 바뀐 위치로 북마크를 갱신하고 이때 301 Moved 상태코드를 사용한다.
- 임시로 옮긴 경우: 임시로 바꼈으니 북마크를 갱신하지 않게 303 See Other과 307 Temporary 상태 코드를 사용한다.

<br>

### 6단계 응답 보내기
클라이언트가 서버에 보내는 것과 마찬가지로 서버도 커넥션 이슈를 직면하므로, 서버는 커넥션 상태를 추적해서 관리해주어야 한다.

지속 커넥션이라면, Content-Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우나 클라이언트가 응답이 언제 끝났는지 알 수 없으면 커넥션은 열린 상태로 유지할 거이다.

<br>

### 7단계 로깅
트랜잭션 완료 시, 어떻게 수행했는지에 대한 로그를 기록한다.
