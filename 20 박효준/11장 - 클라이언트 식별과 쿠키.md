### 클라이언트 식별과 쿠키
> 클라이언트를 식별하여 콘텐츠를 개인화시키는 기법

##

### 개별 접촉
HTTP는 익명(= Stateless)으로 사용하며 상태가 없다. 상태가 없으니 요청/응답은 일회성이고 독립적으로 작용하는 것

서버는 수 많은 클라이언트가 보낸 요청을 처리하고 그 응답을 클라이언트로 전송한다. 이때, 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 정보를 사용할 수 있다.

- 사용자 맞춤 추천: 고객의 생일이나, 기념일 등을 알고 있으면 그에 맞는 상품 제시 가능
- 저장된 사용자 정보: 장바구니, 주소 등등을 알면 더 편하게 유저에게 정보 제공 가능

이처럼 사용자를 식별하여 그에 맞는 기능 제공을 해야하는데 HTTP는 무상태성이므로 요청/응답이 독립적이라 요청이 누군지 알 수 없다.

HTTP 트랜잭션을 식별할 방법이 필요한데, 아래의 여러 방법들을 논의한다.

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 뚱뚱한 URL
- 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술, 쿠키

##

### HTTP 헤더
![2025  8  29  15:12 Microsoft Lens](https://github.com/user-attachments/assets/7814ff7f-103f-47a9-9e14-0f5aa486770d)

위 사진은 사용자에 대한 정보 전달을 위한 대표적인 7가지 HTTP 헤더이다.

그러나, 위 정보들로는 특정 유저를 식별하기에 부족하다. + From 같은 건 개인 정보니 조심해서 사용해야 함

##

### 클라이언트 IP 주소
초기 웹은 클라이언트 IP 주소를 사용하려 했다. IP 주소는 무조건 갖고 있을 거고, 잘 바뀌지도 않고, 요청마다 IP를 알면 문제가 없기 때문이다.

클라이언트 IP 주소는 헤더에 없지만, **TCP 커넥션의 IP 주소**를 알아낼 수 있다. **그러나 아래의 문제들이 존재한다.**

- 클라이언트 IP 주소는 사용자가 아닌, 사용자의 컴퓨터를 가리킨다. 여러 사용자가 같은 컴퓨터를 쓴다면 식별이 불가능하다.
- ISP는 사용자가 로그인하면 동적으로 IP 주소를 할당하는데, 따라서 매번 바뀌니까 웹 서버는 사용자를 IP 주소로 식별할 수 없다.
- 보안을 강화하기 위해 NAT를 사용하는데, 사용자보다 앞단에 있으므로 가려져 사용자를 알 수 없다.

이런 방식은 인트라넷 같이 제한된 영역에서는 적절할 수 있으나, 인터넷은 IP 주소를 임의 변경할 수 있기에 문제가 발생할 수 있다.

##

### 사용자 로그인
IP 주소로 사용자 식별하는 수동적인 방식보다, **웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해 명시적으로 식별을 요청할 수 있다.**

`WWW-Authenticate`와 `Authorization` 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.

한 번 로그인하면, 브라우저는 모든 요청마다 해당 사용자의 식별정보 토큰을 `Authorization` 헤더에 담아 서버에 전송하니, 한 세션이 진행되는 내내 서버는 사용자 식별이 가능하다.

그러나, 웹 사이트 로그인은 귀찮은 일이다.

##

### 뚱뚱한 URL
어떤 웹 사이트는 사용자의 URL 마다 버전을 기술해 사용자를 식별하고 추적했다.

URL 경로의 처음이나 끝에 상태 정보를 추가해서 확장하고 그 사용자가 사이트를 돌아다니면 웹 서버는 URL 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

이렇게 사용자 상태 정보를 포함하는 URL을 뚱뚱한 URL이라 부른다.

그러나, 못생긴 URL이 되고, 공유도 안 되고, URL이 달라지기에 캐시도 못 쓰고, 로그아웃하면 모든 정보를 잃는 등의 문제가 있다.

##

### 쿠키
쿠키는 사용자를 식별하고, 세션을 유지하는 방식 중 현재까지 널리 사용하는 방식이다. 넷스케이프가 최초로 개발했고, 모든 브라우저에서 지원한다.

#### 쿠키의 타입
쿠키는 `세션 쿠키`(Session)와 `지속 쿠키`(Persistent) 두 가지로 나누어 볼 수 있다.

- 세션 쿠키
  - 사용자가 사이트를 탐색할 때, 관련 설정과 선호 사항을 저장하는 '임시 쿠키'이다.
  - 브라우저가 닫히면 사라짐
- 지속 쿠키
  - 사용자가 주기적으로 방문하는 사이트에 대한 설정 & 로그인 이름을 유지하려 한다.
  - **디스크에 저장**하여 브라우저를 닫거나, 컴퓨터를 재시작해도 남아있다.
 
둘의 다른 점을 파기되는 시점뿐이다. 쿠키에 Discard 파라미터, Expries, Max-Age 파라미터가 없으면 세션 쿠키로 취급된다.

<br>

#### 쿠키는 어떻게 동작하는가
쿠키는 서버가 사용자에게 "안녕 내 이름은 ..." 라고 붙이는 스티커와 같다고 한다. 사용자가 웹 사이트 방문 시, 웹 사이트는 사용자에게 붙인 모든 스티커를 읽을 수 있다.

쿠키는 `이름=값` 형태의 리스트를 가지고, `Set-Cookie` 혹은 `Set-Cookie2`(확장헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달된다.

![2025  8  29  16:15 Microsoft Lens](https://github.com/user-attachments/assets/78fdc0c8-e900-423c-a9ef-8f2010714b8e)

처음 사용자가 웹 사이트에 방문하면 서버는 사용자에 아무것도 모른다. 서버는 다시 사용자가 돌아왔을 때, 해당 사용자 식별할 수 있도록 유일한 값을 쿠키에 할당한다.

쿠키는 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적을 위한 용도의 식별번호만 포함하기도 한다.

<br>

#### 쿠키 상자: 클라이언트 측 상태
쿠키는 브라우저가 서버 관련 정보를 저장하고, 사용자가 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다.

브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 '클라이언트 측 상태'라 한다. 공식적인 이름은 `HTTP State Management Mechanism`이다.

<br>

#### 사이트마다 각기 다른 쿠키들
브라우저는 수없이 많은 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.

쿠키를 포함하면 성능이 크게 저하되고, 보안 상의 이유 등이 있기 때문이다. 그래서 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

쿠키에 domain과 path를 적용해서 해당 경로에 접속할 경우에만 쿠키를 전달하게 할 수도 있다.

`e.g. Set-cookie: user=123; domain="abc.com"; path=/autos/`

<br>

#### 쿠키와 캐싱
쿠키 트랜잭션과 관련된 문서를 캐싱하는 건 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당되거나, 개인정보가 노출될 수 있기 때문이다.

응답이 Set-Cookie 헤더를 갖고 있다면, 본문은 캐시할 수 있지만 Set-Cookie 헤더를 캐시하는 건 주의를 기울여야 한다.
