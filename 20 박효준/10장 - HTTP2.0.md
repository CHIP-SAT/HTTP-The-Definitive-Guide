### HTTP/2.0

- HTTP/2.0 만들기 시작한 배경
- HTTP/1.1과의 차이점

##

### HTTP/2.0 등장 배경
HTTP/1.1은 단순성과 접근성에 주안점을 두고 최적화되어, 성능적으로 효율적이지는 못 했다.

그 예로, 커넥션 하나를 통해 요청 하나를 보내고, 그에 대해 응답 하나만을 받는 HTTP 메세지 교환 방식이 단순하긴 하나, 응답을 받아야만 그 다음 요청을 보낼 수 있기에 지연시간이 불가피했다.

이를 해결하고자 병렬 커넥션이나, 파이프라인 커넥션을 도입했지만 성능 개선에 근본 해결책은 못 됐다.

<br>

2009년에 구글이 발표한 SPDY 프로토콜이 등장했는데, 헤더 압축이나 하나의 TCP 커넥션에 여러 요청을 보내는 게 가능해졌다. 이후 SPDY 프로토콜은 HTTP/2.0 프로토콜 설계의 기반이 되었다.

##

### HTTP/2.0 개요
<img width="1124" height="395" alt="스크린샷 2025-08-29 오전 11 29 47" src="https://github.com/user-attachments/assets/309380c8-955f-482d-845c-c9de5616d1de" />

HTTP/2.0은 클라이언트-서버 사이의 TCP 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 입장은 클라이언트이다.

- 한 커넥션 위에 여러 스트림
  - HTTP/2.0 요청과 응답은 한 개 이상의 프레임에 담기게 되고, 프레임은 스트림을 통해 보내진다.
  - 한 개의 스트림이 한 쌍의 요청과 응답을 처리하고, 스트림은 한 커넥션 위에 여러 개가 동시에 만들어질 수 있으므로 여러 요청/응답을 처리하는 게 가능하다.
  - 참고로 스트림에는 흐름 제어와 우선순위 적용도 가능하다.
- 서버푸쉬
  - 서버가 클라이언트에게 필요하다고 생각되는 리소스라면 요청을 안 받아도 능동적으로 응답을 보내줄 수 있다.

##

### HTTP/1.1과의 차이점
#### 프레임
![2025  8  29  11:39 Microsoft Lens](https://github.com/user-attachments/assets/db7cb197-990d-4c8c-aa75-7d9e51f87a24)

**HTTP/2.0의 모든 메세지는 프레임이 담겨 전송**된다. 프레임의 시작은 헤더는 8바이트로, 그 뒤에 페이로드는 16,383(2^14) 바이트 크기로 담겨있다.

- R: 예약된 2비트 필드, 반드시 0이어야 함
- 길이: 페이로드의 길이를 나타내는 무부호 정수 (프레임 헤더에 포함안됨)
- 종류: 프레임 종류
- 플래그: 프레임 종류에 따라 의미가 다름
- R: 예약된 1비트 필드, 반드시 0이어야 함
- 스트림 식별자: 31비트 스트림 식별자로, 0은 커넥션 전체와 연관됨을 의미함

<br>

#### 스트림과 멀티플렉싱
스트림은 프레임의 독립된 양방향 시퀀스이고, 한 커넥션 안에 여러 개의 스트림이 존재한다고 했다.

**한 쌍의 HTTP 요청/응답이 하나의 스트림**으로 이루어지고, 요청을 받은 서버는 **요청을 받은 같은 스트림**에 응답을 보내어 스트림을 닫게 한다.

**HTTP/1.1에서는 요청을 보냈을 때, 응답이 도착해야 그 커넥션에 다시 요청을 보낼 수 있었다.** 그래서 웹은 커넥션 자체를 여러 개 만들어서 동시에 여러 개의 요청을 보내게 했다. 그러나 커넥션을 무한정 만들 수는 없는 노릇이기에 결국 지연을 마주하게 된다.

(커넥션, 스트림 용어 구분 잘하기)

<br>

그래서 HTTP/2.0에서는 **한 커넥션에 여러 개의 스트림을 동시에 열 수 있게** 했다.

또, 스트림 별로 우선순위를 가지게 해서 중요한 리소스의 경우 먼저 처리되게 할 수 있다.

스트림에는 고유한 식별자가 있는데, **한 커넥션에서 한 번 사용한 식별자는 다시 사용할 수 없다.** 고갈되면 다시 커넥션을 맺어버리면 됨

<br>

#### 헤더 압축
HTTP/1.1에서 헤더는 압축없이 그대로 전송되었다.

그러다보니 헤더의 크기가 지연과 대역폭 양쪽에 영향을 끼치게 되었고, SPDY에서는 압축을 통해 해결했다.

<br>

#### 서버 푸쉬
HTTP/2.0은 서버가 한 요청에 한 응답이 아니라, **한 요청에 응답으로 여러 개의 리소스를 보낼 수 있다.**

클라이언트가 어떤 리소스를 요구할 지 미리 알 수 있을 때 유용한데, 이를 통해서 클라이언트가 요청하기 전에 보내므로 트래픽과 회전 지연을 줄여준다.

리소스를 푸시하려는 서버는 `PUSH_PROMISE` 프레임을 보내어 미리 알려주어야 하고, 클라이언트는 이를 받으면 **해당 프레임의 스트림은 '예약됨' 상태가 된다.**

클라이언트도 `RST_STREAM` 프레임을 통해 닫을 수도 있다. 그리고 스트림이 닫히기 전까지는 클라이언트는 서버가 푸쉬하려고 하는 리소스를 요청해서는 안된다. 그래서 서버가 `PUSH_PROMISE` 프레임을 먼저 보내는 것.

##

### 중개자 캡슐화 보안 공격
HTTP/2.0 메세지를 프락시가 1.1 메세지로 변환할 때, 메세지 의미가 변질될 수도 있다.

HTTP/2.0 헤더 필드의 이름과 값을 바이너리로 인코딩해서 어떤 문자열이든 다 사용할 수 있게 해준다.

그러다보니 정상 HTTP/2.0 요청이나 응답이 위조된 HTTP/1.1 메세지로 번역되는 것을 유발할 수 있다.
