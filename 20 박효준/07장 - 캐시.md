## 캐시

### 캐시의 장점
- 불필요한 데이터 전송을 줄여 네트워크 요금으로 인한 비용을 줄여준다.
- 네트워크 병목을 줄여 페이지를 빨리 불러올 수 있게 된다.
- 원 서버에 대한 요청을 줄여 부하를 없애 더 빨리 응답할 수 있다.
- 먼 곳에서 페이지를 부를 수록 시간이 더 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

<br>

### 적중과 부적중
캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 모든 걸 저장하면 그냥 서버 한 대 더 가용한 거랑 다른 거 없을듯

캐시 요청이 왔을 때, 대응하는 사본이 있다면 Cache Hit 적중이라 부른다.

사본이 없다면, 원 서버로 전달될텐데 이때는 Cache Miss 부적중이라 부른다.

<br>

#### 재검사 (Revalidation)
![2025  8  18  16:49 Microsoft Lens](https://github.com/user-attachments/assets/4b66307e-68ea-4724-a451-8a2ee1b48af2)

원 서버 콘텐츠는 변경될 수 있으므로, 캐시는 그들이 갖고 있는 사본이 여전히 최신인지 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 부른다.

캐시는 언제든 스스로 사본을 재검사할 수 있으나, 네트워크 대역폭을 아끼고자 대부분의 캐시는 클라이언트가 사본 요청을 했고 + 그 사본이 검사가 필요한 경우에만 재검사를 한다.

캐시는 캐시된 사본이 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않으면 "304 Not Modified"를 보내는데, 그럼 캐시는 사본이 신선하다고 표시한 후 클라이언트에게 갖고있던 사본을 제공해준다. 이를 "재검사 적중" 혹은 "느린 적중"이라 한다.

이런 느린 적중은 캐시 부적중보다 빠른데, 객체 데이터를 받아올 필요가 없기 때문이다. 304만 받기 때문 ㅇㅇ

<br>

HTTP는 캐시된 객체를 재확인하기 위한 도구를 제공하는데, 그중 조건부 헤더의 "If-Modified-Since" 헤더이다. GET 요청에 이 헤더를 추가하면 `캐시된 시간 이후에 **변경된 경우에만 사본을 보내달라**`는 의미가 된다.

책에서는 클라이언트가 아닌, **캐시가 원 서버에 보내는 예**로 서버 콘텐츠가 '변경되지 않은 경우', '변경된 경우', '삭제된 경우' 세 가지를 설명한다. 아마 클라이언트가 요청하는 것도 같을듯?

- 재검사 적중: 304 Not Modified를 받고, 동시에 바디도 비어있을 것이다.
- 재검사 부적중: 200 OK 응답과 함께 원 서버는 콘텐츠를 바디에 담아 응답을 보낼 것이다.
- 객체 삭제: 404 Not Found를 보내고 캐시는 사본을 삭제한다.

<Br>

#### 적중과 부적중 구별
HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다. 둘 다 200 OK가 될 것이기 때문이다. 

프락시 캐시를 거쳤다면, 무슨 일이 일어났는지 설명하고자 Via 일반 헤더에 추가 정보를 붙일 수 있다.

클라이언트 측에서 응답이 캐시에서 왔는지 알아내는 방법은 Date 일반 헤더를 이용하는 것이다. 현재 시간과 비교하여 오래되면 캐시라고 판단한다.

##

### 캐시 처리 단계
![2025  8  18  17:04 Microsoft Lens](https://github.com/user-attachments/assets/2cf0692e-0e1a-49d1-ab8d-1bd8df5758c0)

웹 캐시의 기본 동작은 아래 7단계의 절차를 가진다.

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메세지를 읽는다.
2. 파싱: 메세지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색: 로컬 복사본이 있는지 검사하고, 사본이 없다면 원 서버로부터 사본을 받아와 로컬에 저장한다.
4. 신선도 검사: 캐시된 사본이 신선한지 검사하고, 신선하지 않으면 변경사항이 있는지 원 서버에 물어본다.
5. 응답 생성: 새로운 헤더와 캐시된 본문으로 응답 메세지를 만든다.
  캐시 서버는 클라이언트에게 원 서버에서 온 것처럼 보이고 싶어하는데, 따라서 서버 응답 헤더를 토대로 응답 헤더를 만든다. 신선도 정보를 나타내는 Cache Control, Age, Expires 헤더들이 포함된다.
6. 발송: 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅: 로그파일에 트랜잭션에 대해 로그를 남긴다.

##

### 사본을 신선하게 유지하기
캐시된 사본 모두가 서버와 일치하는 것은 아니다. 따라서 HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 일관성을 유지할 수 있는 매커니즘을 지니는데, 이를 문서 만료와 서버 재검사라 부른다.

#### 문서 만료
HTTP는 아래와 같이 `Cache-Control`, `Expires` 라는 특별한 헤더를 사용하여 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.

- Expires: Fri, 05 Jul 2002, 05:00:00 GMT
- Cache-Control: max-age=484200

캐시 문서가 만료되기 전에는 서버와 접촉 없이 사본을 제공할 수 있다. 그러나, 만료된 경우라면 캐시는 반드시 서버로부터 문서 변경을 검사해야 하고, 변경이 맞다면 새로운 신선한 사본을 가져와야 한다.

<br>

#### 유효기간과 나이
서버는 HTTP/1.0+의 Expires나, HTTP/1.1의 Cache-Control: max-age 응답 헤더를 통해 유효기간을 명시한다.

그러니까 캐시가 위 헤더가 담긴 응답을 받고 그걸로 자신이 갖고 있는 로컬의 신선도를 체크한다는 거

- Cache-Control: max-age는 문서의 최대 나이를 정의한다. 생성된 이후부터 신선하지 않다고 간주될 때까지 시간의 최댓값으로 초 단위이다.
- Expires는 절대 유효기간, 유효기간이 경과했다면 신선하지 않다는 뜻

<br>

#### 서버 재검사
중요한게, **캐시된 문서의 만료는, 원 서버에 존재하는 것과 실제로 다른 게 아니라 검사할 시간이 되었다**는 뜻이다.

이 검사를 캐시가 원 서버에 문서가 변경되었는지 여부를 물어볼 필요가 있고, 우리는 이것을 '서버 재검사'라고 부른다.

<br>

#### 조건부 메소드와 재검사
HTTP의 조건부 메소드는 재검사에 효율적이다. 캐시가 서버에 GET 요청할 때, 조건부 헤더에 있는 필드를 이용해 조건부 GET을 요청할 수 있는데 이러면 **서버가 갖고 있는 것과 다를 때에만 보내줘**가 된다.

- If-Modified-Since: <date> 만약 문서가 주어진 날짜 이후로 수정됐다면 요청 메소드를 처리한다. 변경된 애들만 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용된다.
- If-None-Match: <tags> 마지막 변경된 날짜를 맞추는 게 아니라, Etag와 같이 태그 값을 통해 처리하고, 태그가 서버의 태그와 다를 때에만 요청을 처리한다.

#### If-Modified-Since: 날짜 재검사
가장 많이 사용하는 캐시 재검사 헤더로, 'IMS' 요청이라고도 불린다. **서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 달라고 하는 것**

- 변경되었다면, GET 요청은 성공할 거고 새 문서와 새 만료 날짜 정보들을 담은 응답이 캐시에게 반환될 것이다.
- 변경된 게 아니라면, 조건은 거짓이고 서버는 304 Not Modified를 클라이언트에게 돌려줄 것이다.

서버의 응답헤더 Last-Modified 헤더와 함께 동작하는데, 원 서버는 제공하는 문서에 최근 변경 일시를 붙인다. 이때 마지막으로 수정된 날짜를 If-Modified-Since: <date>의 date에 넣어 "캐시된 마지막 수정일"을 나타낸다.

<br>

#### If-None-Match: 엔티티 태그 재검사
아래와 같이, 최근 변경 일시 재검사가 어려운 상황이 있을 수 있다.

- 일정 시간 간격으로 다시 쓰이지만, 실제로 같은 데이터를 포함하고 있다면 수정이 안 되어도 시간은 변경될 수 있다.
- 주석 변경과 같은 사소한 변경 사항일 수 있다.

따라서 서버는 엔티티 태그로 새 버전으로 표현할 수 있는데, 엔티티 태그가 변경되었다면 캐시는 새 문서의 사본을 얻기 위해 If-None-Match 조건부 헤더를 사용할 수 있다.

![2025  8  19  10:25 Microsoft Lens](https://github.com/user-attachments/assets/abb56a66-0430-4d8f-9479-8c08723d72ec)

Etag가 같으면 캐시와 서버가 일관된 상태이므로 서버에게 재검사 요청 시, 304 Not Modified를 반환할 거다.

다르면 새 내용과 새 태그를 담아 200 OK를 보낼 거임

<br>

만약 서버가 모든 캐시된 사본을 무효화 시키지 않고 살짝만 문서를 고치고 싶을 수도 있다.

HTTP/1.1은 조금 변경되어도 같다고 표현하는 '약한 검사기(weak validator)'를 지원한다.  반면, 강한 검사기는 콘텐츠가 바뀔 때마다 바뀌는 것을 의미한다.

- Etag: W/"v2.6"
- If-None-Match: W/"v2.6"

위와 같이 W/ 접두사로 약한 검사기를 구분하고, 강한 엔티티 태그는 무조건 태그가 매번 바뀔 것이다.

<br>

#### 언제 엔티티 태그를 사용하고, 언제 Last-Modified 일시를 사용하는가
HTTP/1.1 클라이언트는 서버가 만약 "엔티티 태그"를 반환했다면, 반드시 엔티티 태그 검사기를 사용해야 한다.

만약 서버가 "Last-Modified"를 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.

둘 다 사용 가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있게 클라이언트는 각각을 위해 두 가지 재검사 정책을 모두 사용해야 한다.

캐시나 서버는 If-Modified-Since와 엔티티 태그 조건부 헤더를 모두 받았다면, 모든 조건부 헤더에 부합하지 않는 한 304 Not Modified를 반환하면 안된다.

##

### 캐시 제어
HTTP는 아래 헤더들을 통해, 문서가 만료되기 전까지 얼마나 오랫동안 캐시를 사용하게 할 지 정할 수 있다.

- Cache-Control: no-store
- Cache-Control: no-cache
- Cache-Control: must-revalidate
- Cache-Control: max-age
- Expires 날짜 헤더

#### no-cache와 no-store 응답 헤더
HTTP/1.1은 신선도 관리를 위해 객체를 캐시하는 것을 제한하거나, 캐시된 객체를 제공하는 방법을 제공한다. 여기서 위 두 헤더는 **캐시 서버가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.**

- no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다.
- no-cache: 로컬 캐시 저장소에 저장될 수 있으나, 서버와 재검사 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다. (재검사 없이 캐시에서 제공 X)

<br>

#### Max-Age 응답 헤더
max-age는 신선하다고 간주된 문서가 **서버로부터 온 이후로 흐른 시간**을 나타내고 초로 표현한다.

<br>

#### Expires 응답 헤더
더 이상 사용하지 않기를 권하는 헤더로, 초 단위 시간 대신에 실제 만료 날짜를 명시한다.

Expires: Fri, 05 Jul 2002, 05:00:00 GMT 와 같은 절대 만료 시간을 이용한다.

<br>

#### Must-Revalidate 응답 헤더
캐시는 성능 개선을 위해 신선하지 않은 객체를 제공할 수도 있다.

그래서 서버가 캐시의 이런 방식이 마음에 안 들면 "Cache-Control: must-revalidate"를 설정할 수 있고, 신선하지 않은 경우 최초 재검사 없이 제공해서는 안된다고 명시할 수 있다.

만약 원서버가 사용할 수 없는 상태라 신선도 재검사를 못한다면, 504 Gateway Timeout error를 반환해야 한다.

<br>

#### 클라이언트 신선도 제약
웹 브라우저에서 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신하는 리프레시 버튼이 있다.

이 버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜서 강제로 재검사하거나, 서버로부터 콘텐츠를 무조건 가져온다.

클라이언트도 Cache-Control 요청 헤더를 사용해, 만료 제약을 관리할 수 있는데 상황에 따라 잘 판단하면 된다.

![2025  8  19  10:50 Microsoft Lens](https://github.com/user-attachments/assets/495b4c36-e64b-4c28-8cd8-34d422284056)
