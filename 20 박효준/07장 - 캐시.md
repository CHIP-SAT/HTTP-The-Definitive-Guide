## 캐시

### 캐시의 장점
- 불필요한 데이터 전송을 줄여 네트워크 요금으로 인한 비용을 줄여준다.
- 네트워크 병목을 줄여 페이지를 빨리 불러올 수 있게 된다.
- 원 서버에 대한 요청을 줄여 부하를 없애 더 빨리 응답할 수 있다.
- 먼 곳에서 페이지를 부를 수록 시간이 더 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

<br>

### 적중과 부적중
캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 모든 걸 저장하면 그냥 서버 한 대 더 가용한 거랑 다른 거 없을듯

캐시 요청이 왔을 때, 대응하는 사본이 있다면 Cache Hit 적중이라 부른다.

사본이 없다면, 원 서버로 전달될텐데 이때는 Cache Miss 부적중이라 부른다.

<br>

#### 재검사 (Revalidation)
![2025  8  18  16:49 Microsoft Lens](https://github.com/user-attachments/assets/4b66307e-68ea-4724-a451-8a2ee1b48af2)

원 서버 콘텐츠는 변경될 수 있으므로, 캐시는 그들이 갖고 있는 사본이 여전히 최신인지 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 부른다.

캐시는 언제든 스스로 사본을 재검사할 수 있으나, 네트워크 대역폭을 아끼고자 대부분의 캐시는 클라이언트가 사본 요청을 했고 + 그 사본이 검사가 필요한 경우에만 재검사를 한다.

캐시는 캐시된 사본이 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않으면 "304 Not Modified"를 보내는데, 그럼 캐시는 사본이 신선하다고 표시한 후 클라이언트에게 갖고있던 사본을 제공해준다. 이를 "재검사 적중" 혹은 "느린 적중"이라 한다.

이런 느린 적중은 캐시 부적중보다 빠른데, 객체 데이터를 받아올 필요가 없기 때문이다. 304만 받기 때문 ㅇㅇ

<br>

HTTP는 캐시된 객체를 재확인하기 위한 도구를 제공하는데, 그중 조건부 헤더의 "If-Modified-Since" 헤더이다. GET 요청에 이 헤더를 추가하면 `캐시된 시간 이후에 **변경된 경우에만 사본을 보내달라**`는 의미가 된다.

책에서는 클라이언트가 아닌, **캐시가 원 서버에 보내는 예**로 서버 콘텐츠가 '변경되지 않은 경우', '변경된 경우', '삭제된 경우' 세 가지를 설명한다. 아마 클라이언트가 요청하는 것도 같을듯?

- 재검사 적중: 304 Not Modified를 받고, 동시에 바디도 비어있을 것이다.
- 재검사 부적중: 200 OK 응답과 함께 원 서버는 콘텐츠를 바디에 담아 응답을 보낼 것이다.
- 객체 삭제: 404 Not Found를 보내고 캐시는 사본을 삭제한다.

<Br>

#### 적중과 부적중 구별
HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다. 둘 다 200 OK가 될 것이기 때문이다. 

프락시 캐시를 거쳤다면, 무슨 일이 일어났는지 설명하고자 Via 일반 헤더에 추가 정보를 붙일 수 있다.

클라이언트 측에서 응답이 캐시에서 왔는지 알아내는 방법은 Date 일반 헤더를 이용하는 것이다. 현재 시간과 비교하여 오래되면 캐시라고 판단한다.

##

### 캐시 처리 단계
![2025  8  18  17:04 Microsoft Lens](https://github.com/user-attachments/assets/2cf0692e-0e1a-49d1-ab8d-1bd8df5758c0)

웹 캐시의 기본 동작은 아래 7단계의 절차를 가진다.

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메세지를 읽는다.
2. 파싱: 메세지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색: 로컬 복사본이 있는지 검사하고, 사본이 없다면 원 서버로부터 사본을 받아와 로컬에 저장한다.
4. 신선도 검사: 캐시된 사본이 신선한지 검사하고, 신선하지 않으면 변경사항이 있는지 원 서버에 물어본다.
5. 응답 생성: 새로운 헤더와 캐시된 본문으로 응답 메세지를 만든다.
  캐시 서버는 클라이언트에게 원 서버에서 온 것처럼 보이고 싶어하는데, 따라서 서버 응답 헤더를 토대로 응답 헤더를 만든다. 신선도 정보를 나타내는 Cache Control, Age, Expires 헤더들이 포함된다.
6. 발송: 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅: 로그파일에 트랜잭션에 대해 로그를 남긴다.

