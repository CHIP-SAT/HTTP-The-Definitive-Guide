## 캐시

### 캐시의 장점
- 불필요한 데이터 전송을 줄여 네트워크 요금으로 인한 비용을 줄여준다.
- 네트워크 병목을 줄여 페이지를 빨리 불러올 수 있게 된다.
- 원 서버에 대한 요청을 줄여 부하를 없애 더 빨리 응답할 수 있다.
- 먼 곳에서 페이지를 부를 수록 시간이 더 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

<br>

### 적중과 부적중
캐시가 세상 모든 문서의 사본을 저장하지는 않는다. 모든 걸 저장하면 그냥 서버 한 대 더 가용한 거랑 다른 거 없을듯

캐시 요청이 왔을 때, 대응하는 사본이 있다면 Cache Hit 적중이라 부른다.

사본이 없다면, 원 서버로 전달될텐데 이때는 Cache Miss 부적중이라 부른다.

<br>

#### 재검사 (Revalidation)
![2025  8  18  16:49 Microsoft Lens](https://github.com/user-attachments/assets/4b66307e-68ea-4724-a451-8a2ee1b48af2)

원 서버 콘텐츠는 변경될 수 있으므로, 캐시는 그들이 갖고 있는 사본이 여전히 최신인지 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 부른다.

캐시는 언제든 스스로 사본을 재검사할 수 있으나, 네트워크 대역폭을 아끼고자 대부분의 캐시는 클라이언트가 사본 요청을 했고 + 그 사본이 검사가 필요한 경우에만 재검사를 한다.

캐시는 캐시된 사본이 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않으면 "304 Not Modified"를 보내는데, 그럼 캐시는 사본이 신선하다고 표시한 후 클라이언트에게 갖고있던 사본을 제공해준다. 이를 "재검사 적중" 혹은 "느린 적중"이라 한다.

이런 느린 적중은 캐시 부적중보다 빠른데, 객체 데이터를 받아올 필요가 없기 때문이다. 304만 받기 때문 ㅇㅇ

<br>

HTTP는 캐시된 객체를 재확인하기 위한 도구를 제공하는데, 그중 조건부 헤더의 "If-Modified-Since" 헤더이다. GET 요청에 이 헤더를 추가하면 `캐시된 시간 이후에 **변경된 경우에만 사본을 보내달라**`는 의미가 된다.

책에서는 클라이언트가 아닌, **캐시가 원 서버에 보내는 예**로 서버 콘텐츠가 '변경되지 않은 경우', '변경된 경우', '삭제된 경우' 세 가지를 설명한다. 아마 클라이언트가 요청하는 것도 같을듯?

- 재검사 적중: 304 Not Modified를 받고, 동시에 바디도 비어있을 것이다.
- 재검사 부적중: 200 OK 응답과 함께 원 서버는 콘텐츠를 바디에 담아 응답을 보낼 것이다.
- 객체 삭제: 404 Not Found를 보내고 캐시는 사본을 삭제한다.

<Br>

#### 적중과 부적중 구별
HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다. 둘 다 200 OK가 될 것이기 때문이다. 

프락시 캐시를 거쳤다면, 무슨 일이 일어났는지 설명하고자 Via 일반 헤더에 추가 정보를 붙일 수 있다.

클라이언트 측에서 응답이 캐시에서 왔는지 알아내는 방법은 Date 일반 헤더를 이용하는 것이다. 현재 시간과 비교하여 오래되면 캐시라고 판단한다.

##

### 캐시 처리 단계
![2025  8  18  17:04 Microsoft Lens](https://github.com/user-attachments/assets/2cf0692e-0e1a-49d1-ab8d-1bd8df5758c0)

웹 캐시의 기본 동작은 아래 7단계의 절차를 가진다.

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메세지를 읽는다.
2. 파싱: 메세지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색: 로컬 복사본이 있는지 검사하고, 사본이 없다면 원 서버로부터 사본을 받아와 로컬에 저장한다.
4. 신선도 검사: 캐시된 사본이 신선한지 검사하고, 신선하지 않으면 변경사항이 있는지 원 서버에 물어본다.
5. 응답 생성: 새로운 헤더와 캐시된 본문으로 응답 메세지를 만든다.
  캐시 서버는 클라이언트에게 원 서버에서 온 것처럼 보이고 싶어하는데, 따라서 서버 응답 헤더를 토대로 응답 헤더를 만든다. 신선도 정보를 나타내는 Cache Control, Age, Expires 헤더들이 포함된다.
6. 발송: 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅: 로그파일에 트랜잭션에 대해 로그를 남긴다.

##

### 사본을 신선하게 유지하기
캐시된 사본 모두가 서버와 일치하는 것은 아니다. 따라서 HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 일관성을 유지할 수 있는 매커니즘을 지니는데, 이를 문서 만료와 서버 재검사라 부른다.

#### 문서 만료
HTTP는 아래와 같이 `Cache-Control`, `Expires` 라는 특별한 헤더를 사용하여 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.

- Expires: Fri, 05 Jul 2002, 05:00:00 GMT
- Cache-Control: max-age=484200

캐시 문서가 만료되기 전에는 서버와 접촉 없이 사본을 제공할 수 있다. 그러나, 만료된 경우라면 캐시는 반드시 서버로부터 문서 변경을 검사해야 하고, 변경이 맞다면 새로운 신선한 사본을 가져와야 한다.

<br>

#### 유효기간과 나이
서버는 HTTP/1.0+의 Expires나, HTTP/1.1의 Cache-Control: max-age 응답 헤더를 통해 유효기간을 명시한다.

그러니까 캐시가 위 헤더가 담긴 응답을 받고 그걸로 자신이 갖고 있는 로컬의 신선도를 체크한다는 거

- Cache-Control: max-age는 문서의 최대 나이를 정의한다. 생성된 이후부터 신선하지 않다고 간주될 때까지 시간의 최댓값으로 초 단위이다.
- Expires는 절대 유효기간, 유효기간이 경과했다면 신선하지 않다는 뜻

<br>

#### 서버 재검사
중요한게, **캐시된 문서의 만료는, 원 서버에 존재하는 것과 실제로 다른 게 아니라 검사할 시간이 되었다**는 뜻이다.

이 검사를 캐시가 원 서버에 문서가 변경되었는지 여부를 물어볼 필요가 있고, 우리는 이것을 '서버 재검사'라고 부른다.

<br>

#### 조건부 메소드와 재검사
HTTP의 조건부 메소드는 재검사에 효율적이다. 캐시가 서버에 GET 요청할 때, 조건부 헤더에 있는 필드를 이용해 조건부 GET을 요청할 수 있는데 이러면 **서버가 갖고 있는 것과 다를 때에만 보내줘**가 된다.

- If-Modified-Since: <date> 만약 문서가 주어진 날짜 이후로 수정됐다면 요청 메소드를 처리한다. 변경된 애들만 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용된다.
- If-None-Match: <tags> 마지막 변경된 날짜를 맞추는 게 아니라, Etag와 같이 태그 값을 통해 처리하고, 태그가 서버의 태그와 다를 때에만 요청을 처리한다.

#### If-Modified-Since: 날짜 재검사
가장 많이 사용하는 캐시 재검사 헤더로, 'IMS' 요청이라고도 불린다. **서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 달라고 하는 것**

- 변경되었다면, GET 요청은 성공할 거고 새 문서와 새 만료 날짜 정보들을 담은 응답이 캐시에게 반환될 것이다.
- 변경된 게 아니라면, 조건은 거짓이고 서버는 304 Not Modified를 클라이언트에게 돌려줄 것이다.

Last-Modified 헤더와 함께 동작하는데, 원 서버는 제공하는 문서에 최근 변경 일시를 붙인다. 

