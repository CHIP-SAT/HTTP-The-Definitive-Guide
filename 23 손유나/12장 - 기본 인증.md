### 12.1 인증

- 인증은 당신이 누구인지 증명하는 것
- **간략하게 묘사한 인증요구/응답**
  <img width="514" height="889" alt="image" src="https://github.com/user-attachments/assets/30b159b9-677b-434e-bdbd-d87c8d3c11d5" />

- **네 가지 인증 단계**

  <img width="562" height="733" alt="image" src="https://github.com/user-attachments/assets/6b482bc7-b5b8-4cc1-bffc-ce951f91fb31" />


- **기본 인증 예시**

  <img width="562" height="627" alt="image" src="https://github.com/user-attachments/assets/bae52141-1d7c-4e14-b615-ac294a39ecd7" />

- **HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는가?**
    - 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눔.
    - 보안 영역은 저마다 다른 사용자 권한을 요구함.
    - 예시
        - `realm` 파라미터가 함께 기술된 기본 인증의 예
            
            ```jsx
            HTTP/1.0 401 Unauthorized
            WWW-Authenticate: Basic realm='Corporate Financials'
            ```
            
          <img width="548" height="589" alt="image" src="https://github.com/user-attachments/assets/8295ab48-4d47-45a2-890f-affebdf44848" />


---

### 12.2 기본 인증

- 기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있음.
- 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 `WWW-Authenticate`에 기술해서 응답하여 인증요구를 시작함.
- 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 `Authorization` 요청 헤더 안에 암호화해서 서버로 다시 전송함.

- **기본 인증 헤더**

  <img width="564" height="452" alt="image" src="https://github.com/user-attachments/assets/30981ece-76d0-4956-89fc-410feeedfb27" />

    - 기본 인증 헤더는 `Authentication-Info` 헤더를 사용하지 않음.
- base-64 인코딩: 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환 → 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택됨.
- 사용자 이름과 비밀번호로 기본 `Authorization` 헤더 생성하기
  <img width="552" height="696" alt="image" src="https://github.com/user-attachments/assets/3984e641-deb8-4f76-8b07-03162eed222d" />

- 어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증함.
    - 웹 서버와 프락시 인증에서 쓰이는 상태 코드와 헤더들의 대조표
      <img width="559" height="329" alt="image" src="https://github.com/user-attachments/assets/4fe9926a-25f7-4014-b499-ba854a0754a2" />


---

### 12.3 기본 인증의 보안 결함

1. base-64로 인코딩된 사용자 이름과 비밀번호는 인코딩 절차를 반대로 수행해서 어렵지 않게 디코딩할 수 있음.
    - 대안 ⇒ 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋음.
2. 제 3자가 사용자 이름과 비밀번호를 캡처하여 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있음.
    - 기본 인증은 재전송 공격을 예방하기 위한 어떤 일도 하지 않음.
3. 메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않음.
4. 기본 인증은 가짜 서버의 위장에 취약함.
    - 만약 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것임.
