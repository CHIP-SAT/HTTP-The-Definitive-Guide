### 6.1 웹 중개자

- 웹 프락시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인임.
- 프락시는 서버이면서 동시에 클라이언트여야 함.
    
    <img width="534" height="267" alt="image" src="https://github.com/user-attachments/assets/6f78595f-d0ea-43c6-adbe-3bedc0efb4ff" />

    
- **공용 프락시**
    - 여러 클라이언트가 함께 사용하는 프락시
    - 대부분의 프락시는 공용이며 공유된 프락시임.
    - 중앙 집중형 프락시를 관리하는 게 더 비용효율이 높고 쉬움.
    - 캐시 프락시 서버와 같은 몇몇 프락시 애플리케이션은 프락시를 이용하는 사용자가 많을 수록 유리함.
        - 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문
- **개인 프락시**
    - 하나의 클라이언트만을 위한 프락시
    - 어떤 브라우저 보조 제품들은 몇몇 ISP 서비스와 마찬가지로 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 ISP 서비스를 위한 광고를 운영하기 위해 작은 프락시를 사용자의 컴퓨터에서 직접 실행함.
- **프락시 vs 게이트웨이**
    - 프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
    - 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결(like 프로토콜 변환기)
      <img width="513" height="401" alt="image" src="https://github.com/user-attachments/assets/6d9cc938-2e10-4deb-882c-472d3f39237b" />

    - 실질적으로 프락시와 게이트웨이의 차이는 모호함.
        - 이유
            - 브라우저와 서버는 다른 버전의 HTTP를 구현하기 때문에, 프락시는 때때로 약간의 프로토콜 변환을 함.
            - 또한 프락시 서버는 SSL 보안 프로토콜, SOCKS 방화벽, FTP 접근, 웹 기반 애플리케이션을 지원하기 위해 게이트웨이 기능을 구현함.

---

### 6.2 왜 프락시를 사용하는가?

- 프락시는 보안을 개선하고, 성능을 높여주며, 비용을 절약함.
- 프락시 서버는 모든 HTTP 트래픽을 들여다보고 건드릴 수 있기 때문에, 프락시는 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있음.
- **어린이 필터**
    - 교육 콘텐츠에는 제한 없는 접근 허용, 부적절한 사이트의 접근은 강제로 거부
- **문서 접근 제어자**
    - 프락시 서버는 많은 웹 서버들과 웹 리소스에 대한 단일한 접근 제어 전략을 구현하고 감사 추적을 하기 위해 사용될 수 있음.
        - 감사 추적 : 웹 리소스 및 서버에 대한 접근·변경 등의 활동 이력을 기록(로그)으로 남기고, 사후에 보안 이상 여부나 문제 발생 원인을 추적할 수 있게 하는 활동
    - 중앙화된 접근 제어 프락시가 하는 일
        <img width="539" height="445" alt="image" src="https://github.com/user-attachments/assets/510a97fe-82d7-4393-9ddd-24d9cee804d3" />

        - 클라이언트 1에게 제약 없이 서버의 뉴스 페이지에 접근할 수 있도록 허가
        - 클라이언트 2에게 제약 없이 인터넷 콘텐츠에 접근할 수 있는 권한을 줌.
        - 클라이언트 3이 서버 B에 접근하기 전에 먼저 비밀번호를 요구
- **보안 방화벽**
    - 프락시 서버는 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제함.
  
      <img width="532" height="420" alt="image" src="https://github.com/user-attachments/assets/3e71ebe5-6b97-404b-9c53-c480dbaa418c" />

- **웹 캐시**
    - 프락시 캐시는 인기 있는 문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄임.
      <img width="537" height="467" alt="image" src="https://github.com/user-attachments/assets/d24bac14-084f-4197-8dae-ca9b09416f14" />

- **대리 프락시(리버스 프락시)**
    - 진짜 웹 서버 요청을 받지만 웹 서버와는 달리 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션 함.
    - 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용될 수 있음.(서버 가속기)
    - 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용될 수 있음.
        - 여러 서버/지역에 콘텐츠 복제본을 배치해두고, 사용자의 요청이 들어올 때마다 가장 적절한 복제 서버로 트래픽을 분배해, 빠른 응답과 효율적인 네트워크를 사용할 수 있도록 한다는 의미
      <img width="529" height="235" alt="image" src="https://github.com/user-attachments/assets/f6ee2dcc-fe9a-43ba-8d1e-a01558104816" />

- **콘텐츠 라우터**
    - 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작 가능
    - 예를 들어 사용자나 콘텐츠 제공자가 더 높은 성능을 위해 돈을 지불했다면, 콘텐츠 라우터는 요청을 가까운 복제 캐시로 전달할 수 있음.
    - 사용자가 필터링 서비스에 가입했다면 HTTP 요청이 필터링 프락시를 통과하도록 할 수도 있음.
      <img width="520" height="619" alt="image" src="https://github.com/user-attachments/assets/adace133-c745-411f-8e7c-6e3db74d32a2" />

- **트랜스코더**
    - 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정 가능
    - 트랜스코딩 프락시는 크기를 줄이기 위해 자신을 거쳐 가는 GIF 이미지를 JPG 이미지로 변환하거나, 텍스트 파일을 압축하거나, 작은 텍스트로 줄인 웹페이지를 생성, 문서를 바로 외국어 문서로 변환 가능
        - 트랜스코딩 : 데이터의 표현 방식을 자연스럽게 변환하는 것
      <img width="538" height="407" alt="image" src="https://github.com/user-attachments/assets/47eacf81-c1f0-499c-bc03-4e46fafd3c4c" />

- **익명화 프락시**
    - HTTP 메시지에서 신원을 식별할 수 있는 특성들을 적극적으로 제거함으로써 개인 정보 보호와 익명성 보장에 기여
    - 익명화 프락시가 변경하는 사용자 메시지
        - User-Agent 헤더에서 사용자의 컴퓨터와 OS의 종류를 제거
        - 사용자의 이메일 주소를 보호하기 위해 From 헤더 제거
        - 어떤 사이트를 거쳐서 방문했는지 알기 어렵게 하기 위해 Referer 헤더 제거
        - 프로필과 신원 정보를 없애기 위해 Cookie 헤더 제거
      <img width="530" height="325" alt="image" src="https://github.com/user-attachments/assets/b2396238-dd89-4620-8b50-e84d679edf06" />


---

### 6.3 프락시는 어디에 있는가?

- **어떻게 프락시가 네트워크에 배치되는가**
    - 프락시는 사용 목적에 따라 여러 가지 방식으로 배치될 수 있음.
    - **출구 프락시**
        - 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프락시를 로컬 네트워크의 출구에 박아 넣음.
          <img width="580" height="216" alt="image" src="https://github.com/user-attachments/assets/a14fa87c-e22f-4d4c-9b8f-3144d55d4cc5" />

    - **접근 프락시**
        - 고객으로부터의 모든 요청을 종합적으로 처리하기 위해 ISP 지점에 위치
        - ISP는 사용자들의 다운로드 속도를 개선하고 인터넷 대역폭 비용을 줄이기 위해 캐시 프락시를 사용
          <img width="542" height="213" alt="image" src="https://github.com/user-attachments/assets/aee21c9c-507f-4472-9371-1d8348dd25c6" />

    - **대리 프락시**
        - 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청
        - 웹 서버에 보안 기능을 추가하거나 빠른 웹 서버 캐시를 느린 웹 서버의 앞에 놓음으로써 성능 개선
        - 대리 프락시는 일반적으로 웹 서버의 이름과 IP 주소로 스스로를 가장하기 때문에, 모든 요청은 서버가 아닌 이 프락시로 가게 됨.
          <img width="530" height="220" alt="image" src="https://github.com/user-attachments/assets/5b027356-d225-4c4c-a261-7f70209339cb" />

    - **네트워크 교환 프락시**
        - 캐시를 이용해 인터넷 교차로의 혼잡을 완화
        - 트래픽 흐름을 감시하기 위해 충분한 처리 능력을 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환 지점들에 위치
          <img width="530" height="213" alt="image" src="https://github.com/user-attachments/assets/f9cebfba-b412-4850-83f4-002b2c69f718" />

- **어떻게 프락시의 연쇄가 계층을 이루는가**
    - 프락시 계층에서 메시지는 최종적으로 원 서버에 도착할 때까지 프락시와 프락시를 거쳐 이동함.
    - 프락시 계층에서 프락시 서버들은 부모와 자식 관계를 가짐.
      <img width="521" height="200" alt="image" src="https://github.com/user-attachments/assets/08ed566b-684b-4748-a350-670e98020a73" />

    - 프락시 서버는 여러 가지 판단 근거에 의해 메시지를 다양하고 유동적인 프락시 서버와 원 서버들의 집합에 전송 가능
    - **동적 부모 선택의 예시**
        - **부하 균형**
            - 자식 프락시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고름.
        - **지리적 인접성에 근거한 라우팅**
            - 자식 프락시는 원 서버의 지역을 담당하는 부모를 선택 가능
                - 원 서버의 지역을 담당하는 부모 : 여러 부모 후보 중에서 해당 콘텐츠나 원 서버와 더 가까운 특정 부모
        - **프로토콜/타입 라우팅**
            - 어떤 자식 프락시는 URI에 근거하여 다른 부모나 원 서버로 라우팅 가능
        - **유료 서비스 가입자를 위한 라우팅**
            - 웹 서비스 운영자가 빠른 서비스를 위해 추가금을 지불했다면, 그들의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 가능
- **어떻게 트래픽이 올바르게 프락시를 찾아가는가**
    - **클라이언트 트래픽이 프락시로 가도록 만드는 4가지 방법**
        1. **클라이언트 수정**
            - 구글 크롬과 마이크로소프트의 브라우저를 포함한 웹 클라이언트들은 수동 혹은 자동 프락시 설정을 지원
        2. **네트워크 수정**
            - 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정 (인터셉트 프락시)
        3. **DNS 이름 공간 수정**
            - DNS 이름 테이블을 수동으로 편집하거나 사용할 적절한 프락시나 서버를 계산해주는 특별한 동적 DNS 서버를 이용해서 조절
        4. **웹 서버 수정**
            - 리다이렉션 명령을 돌려줄 때 프락시로 리다이렉트 하도록 설정

---

### 6.5 프락시 요청의 미묘한 특징들

- 프락시 URI는 서버 URI와 다름.
    - 웹 서버로 요청을 보내는 경우 `스킴`, `호스트`, `포트번호`가 없는 **부분 URI**를 가짐.
        
        ```jsx
        GET /index.html HTTP/1.0
        User-Agent: SuperBrowserv1.3
        ```
        
    - 프락시로 요청을 보내는 경우 **완전한 URI**를 가짐.
        
        ```jsx
        GET http://www.marys-antiques.com/index.html HTTP/1.0
        User-Agent: SuperBrowser v1.3
        ```
        

- **왜 서버와 프락시는 각각 다른 요청 형식을 갖는가?**
    - 원래의 HTTP 설계에서 클라이언트는 자신의 호스트 명과 포트번호를 알고있는 단일한 서버와 직접 대화를 나눔. → 불필요한 정보 발송을 피하기 위해 스킴과 호스트, 포트번호가 없는 부분 URI만 보냄.
    - 프락시는 목적지 서버와 커넥션을 맺어야 하기 때문에 그 서버의 이름을 알 필요가 있고, 프락시 기반 게이트웨이는 스킴과 연결하기 위해 URI의 스킴을 알아야 함. → 완전한 URI 요구
- 가상으로 호스팅 되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유함.
    - 요청이 부분 URI로 오면, 가상으로 호스팅 되는 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 있음.
    - 따라서 가상으로 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구함.
- 인터셉트 프락시는 부분 URI를 받음.
    - 클라이언트가 프락시를 사용하지 않는다고 설정되어 있어도, 클라이언트의 트래픽은 여전히 대리 프락시나 인터셉트 프락시를 지날 수 있음. → 하지만 클라이언트는 자신이 웹 서버와 대화하고 있다고 생각하기 때문에 부분 URI를 보냄.
- 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있음.
    - 프락시는 명시적인 프락시 요청에 대해서는 완전한 URI를 사용하고 아니면 부분 URI를 사용해야 하며, 웹 서버 요청의 경우에는 가상 Host 헤더를 사용해야 함.
- 프락시 서버는 요청 URI의 변경에 매우 신경 써야함.
    - 무해해 보이는 사소한 URI 변경이라도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있음.
- 또한 프락시 서버는 프로토콜을 엄격하게 준수하도록 강제하려 해서는 안됨.
- HTTP 명세는 일반적인 인터셉트 프락시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지함.
- 브라우저는 프락시의 존재 여부에 따라 요청 URI를 다르게 분석함.
    - **프락시 없는 URI 분석**
        - 브라우저는 명시적인 프락시가 존재하지 않는 경우 부분 호스트 명을 자동으로 확장함.
          <img width="532" height="364" alt="image" src="https://github.com/user-attachments/assets/ff1a5bbe-f5b2-4c1d-8c28-04eb66fb69b3" />

    - **명시적인 프락시를 사용할 때의 URI 분석**
        - 브라우저는 명시적인 프락시가 있는 경우 부분 호스트 명을 자동확장하지 않음.
          <img width="536" height="444" alt="image" src="https://github.com/user-attachments/assets/6c35b302-0892-4a52-a24a-3c487770dbb2" />

- 인터셉트 프락시를 사용하고 있는 브라우저는 죽은 서버의 IP주소를 탐지할 수 없음.
    <img width="527" height="342" alt="image" src="https://github.com/user-attachments/assets/30f23746-0d6a-4f05-b34f-7d19cb854fb7" />


---

### 6.6 메시지 추적

- 프락시가 점점 더 흔해지면서, 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요하게 됨.
- `Via` 헤더
    - 메시지가 지나는 각 중간 노드의 정보를 나열
    - 메시지가 또 다른 노드를 지날 때 마다, 중간 노드는 Via 목록의 끝에 반드시 추가되어야 함.
    - `Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com`
        - 의미 : 첫 번째 프락시는 HTTP/`1.1` 프로토콜을 구현했으며 `proxy-62.irenes-isp.net`라 불리고, 두 번째 프락시는 HTTP/`1.0`을 구현했고 `cache.joes-hardware.com`로 불림
    - 프락시는 또한 네트워크의 라우팅 루프를 탐지하기 위해 `Via` 헤더를 사용할 수도 있음.
        - 요청을 보내기 전 자신을 가리키는 유일한 문자열을 `Via` 헤더에 삽입 & 들어온 요청에 이 문자열이 있는지 검사하여 네트워크에 라우팅 루프가 있는지 탐지
- 응답 메시지가 프락시를 통과할 때, 프락시는 Server 헤더를 수정해서는 안됨.
-` Via`가 개인정보 보호와 보안에 미치는 영향
    - 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 방화벽 뒤에 숨어있는 호스트의 이름과 포트를 전달해서는 안됨. ⇒ 호스트 명을 가명으로 교체해야 함.
    - 프락시는 정렬된 일련의 Via 경유지 항목들(수신된 프로토콜 값들이 동일한)을 하나로 합칠 수 있음.
        
        ```jsx
        Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
        ⇒ Via: 1.0 foo, 1.1 concealed-stuff
        ```
        
        - 하지만 여러 경유지들이 모두 같은 조직의 통제하에 있고 호스트가 이미 가명으로 교체되지 않은 이상 그들에 대한 항목들을 합쳐서는 안되고, 수신된 프로토콜 값이 서로 다른 항목들도 합쳐서는 안됨.
- `TRACE` 메서드
    - 프락시 서버는 메시지가 전달될 때 메시지 수정 가능
        - 헤더 추가, 변경, 삭제, 본문 형식 변환 등
    - HTTP/1.1의 `TRACE` 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적할 수 있도록 해줌.
    - 어떻게?
        - 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시킴으로써
          <img width="539" height="560" alt="image" src="https://github.com/user-attachments/assets/1446efdd-5cbb-4ce8-a074-6d856b396ce9" />

    - `Max-Forwards` 헤더 : `TRACE`와 `OPTIONS` 요청의 프락시 홉 개수를 제한하기 위한 헤더로, 전달되는 메시지가 무한 루프에 빠지지 않는지 프락시 연쇄를 테스트하거나 연쇄 중간의 특정 프락시 서버들의 효과를 체크할 때 유용함. (+ OPTIONS 메시지의 전달 횟수도 제한함.)
    - `Max-Forwards` 요청 헤더 필드는 이 요청 메시지가 몇 번 더 다음 홉으로 전달될 수 있는지 말해주는 정수를 하나 담고 있는데 이 값이 0이 되면 메시지를 더 이상 전달하지 말고 반드시 클라이언트에게 돌려줘야 함.

---

### 6.7 프락시 인증

- HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의함.
- 제한된 콘텐츠에 대한 요청이 프락시 서버에 도착하면, 프락시 서버는 `407` 상태 코드와 자격을 제출할 수 있는 방법을 알려주는 `Proxy-Authenticate` 헤더 필드와 함께 반환함.
  <img width="519" height="713" alt="image" src="https://github.com/user-attachments/assets/e8f3625b-c734-4418-99d8-34ba46c965ca" />


---

### 6.8 프락시 상호운용성

- 프락시 서버는 넘어오는 헤더들을 모두 이해하지 못할 수 있음.
    - 이해할 수 없는 헤더 필드(또한 메서드)는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 함.
- `OPTIONS`는 서버가 지원하는 메서드를 찾기 위해 사용할 수도 있음.
    <img width="829" height="260" alt="image" src="https://github.com/user-attachments/assets/62600e73-e45e-4159-9e94-9da5a5568c88" />

    - OPTIONS의 URI가 `*`라면 서버 전체의 능력에 대해 묻는 것이고, URI가 실제 리소스라면 특정 리소스에 대해 가능한 기능들을 묻는 것임.
- Allow 헤더는 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거하지만, 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용될 수도 있음.
