### 7.1 불필요한 데이터 전송

- 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 줌.
- 캐시를 이용하면 첫 번째 서버 응답이 캐시에 보관되기 때문에, 뒤이은 요청들에 대한 응답으로는 캐시된 사본이 사용됨. → 원 서버가 중복해서 중복해서 트래픽을 주고받는 낭비가 줄어듬.

---

### 7.2 대역폭 병목

- 로컬 네트워크의 대역폭 > 원격 서버의 대역폭
- 클라이언트가 서버에 접근할 때의 속도 == 클라이언트와 서버 간의 경로에 있는 가장 느린 네트워크의 속도
- 대역폭은 큰 문서에 대해 지연을 일으킴.
- 네트워크 속도는 네트워크 종류에 따라 달라짐.

---

### 7.4 거리로 인한 지연

- 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있음.
- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴.
- 클라이언트와 서버 사이에 라우터가 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발함.
- 이를 모두 정리하면, 거리가 멀고 페이지가 복잡할 수록 빛의 속도조차 느리게 느껴질 만큼, 현실적인 페이지 로딩 지연이 쌓일 수 있음.
  <img width="524" height="703" alt="image" src="https://github.com/user-attachments/assets/ece0e442-4127-4145-aa5a-85277f511846" />


---

### 7.5 적중과 부적중

- **캐시 적중이란?**
    - 캐시에 요청이 도착했을 때, 이에 대응하는 사본이 있어 그 사본을 이용해 요청이 처리될 수 있는 경우
- **캐시 부적중(캐시 미스)이란?**
    - 캐시에 대응하는 사본이 없어, 원 서버로 요청이 전달되는 경우
- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검해야 함. (= HTTP 재검사)
- 캐시는 스스로 원한다면 언제든지 사본 재검사 가능
    - but 네트워크 대역폭은 부족하기 때문에, 대부분의 캐시는 클라이언트가 사본을 요청했고, 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 함.
- **순수 캐시 적중 속도 > 재검사 적중 속도 > 캐시 부적중**
    - 이유 : 원 서버와 검사해야 하기 때문에 순수 캐시 적중 속도보단 느리지만, 서버로부터 객체 데이터를 받아올 필요가 없기 때문에 캐시 부적중보다는 빠름.
- 캐시된 객체를 재확인하기 가장 많이 사용되는 HTTP 헤더 : `If- Modified-Since`
    - GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
- **GET `If- Modified-Since` 요청이 서버에 도착했을 때 일어날 수 있는 3가지 상황**
    1. 서버 콘텐츠가 변경되지 않은 경우 (재검사 적중(느린 적중))
        - 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP `304 Not Modified` 응답을 보냄.
          <img width="529" height="369" alt="image" src="https://github.com/user-attachments/assets/6abf09b3-dc1c-4b76-bc43-9dfacca8f406" />

    2. 서버 콘텐츠가 변경된 경우
        - 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP `200 OK` 응답을 보냄.
    3. 객체가 삭제된 경우
        - 서버 객체가 삭제되었다면, 서버는 `404 Not Found` 응답을 보내고, 캐시는 사본을 삭제함.
- **캐시 적중률이란?**
    - 캐시가 요청을 처리하는 비율
    - 0% ⇒ 모든 요청이 캐시 부적중
    - 100% ⇒ 모든 요청이 캐시 적중
- **캐시 적중률에 영향을 주는 요인**
    - **캐시 크기**
        - 캐시 용량이 클수록 더 많은 데이터를 저장할 수 있어 적중률이 높아짐.
    - **사용자 관심사의 유사성**
        - 사용자들이 비슷한 데이터를 요청할수록 캐시된 데이터를 재사용할 확률이 높아짐.
    - **데이터 변경/개인화 빈도**
        - 데이터가 자주 변경되거나 개인화될수록 기존 캐시 데이터가 무효화되어 적중률이 떨어짐.
    - **캐시 설정 방식**
        - 캐시 정책(ex. LRU 등)과 구성에 따라 적중률이 달라짐.
- **바이트 단위 적중률이란?**
    - 캐시를 통해 제공된 모든 바이트의 비율
    - 트래픽이 절감된 정도를 포착해냄.
    - 100% ⇒ 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미
- **캐시 적중률**은 얼마나 많은 **웹 트랜잭션**을 외부로 내보내지 않았는지를 보여줌.
    - 트랜잭션은 고정된 소요 시간을 포함하기 때문에 캐시 적중률을 개선하면 전체 대기시간(지연)이 줄어듬.
- **바이트 단위 적중률**은 얼마나 많은 **바이트**가 인터넷으로 나가지 않았는지를 보여줌.
    - 바이트 단위 적중률의 개선은 대역폭 절약을 최적화함.
- HTTP는 응답이 캐시에서 왔는지 원 서버에서 왔는지 말해줄 수 있는 방법을 제공하지 않음.
    - 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은?
        - `Date` 헤더를 이용
            - 응답의 `Date` 헤더 값을 현재 시각과 비교 → 응답의 생성일이 더 오래되었다면 그 응답은 캐시된 것임을 알 수 있음.
        - 혹은 응답이 얼마나 오래되었는지 말해주는 `Age` 헤더를 이용
    - Q. `Via` 헤더를 통해 거쳐간 경로를 알 수 있는데, 이를 통해 캐시에서 온 건지 서버에서 온 건지 알 수 있지 않은가?
        - `Via` 헤더는 요청이나 응답이 캐시나 프록시를 거쳤는지는 알 수 있지만, 실제로 캐시에서 직접 응답한 것인지는 이 헤더만으로는 확실히 알 수 없음.

---

### 7.6 캐시 토폴로지

- **개인 전용 캐시(private cache)**
    - 개인만을 위한 캐시
    - 한 명의 사용자가 자주 찾는 페이지를 담음.
      <img width="527" height="167" alt="image" src="https://github.com/user-attachments/assets/de237605-882c-49c6-bf87-959ca9e6c461" />

    - 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용함.
      <img width="524" height="350" alt="image" src="https://github.com/user-attachments/assets/55270816-5721-48b5-829d-e5c4ba8af751" />

- **공용 캐시(public cache)**
    - 공유된 캐시
    - 사용자 집단에게 자주 쓰이는 페이지를 담음.
      <img width="523" height="240" alt="image" src="https://github.com/user-attachments/assets/a5fa279b-387a-42af-95d2-c358f5b9d1a1" />

    - 공용 캐시는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있음.
        - 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공할 수 있기 때문
      <img width="822" height="334" alt="image" src="https://github.com/user-attachments/assets/9b329aed-ee23-4af8-a5f2-b6c2d4e19fdb" />

- **프락시 캐시 계층**
  <img width="529" height="619" alt="image" src="https://github.com/user-attachments/assets/a1fed1db-10f1-4925-bc53-596fec731286" />

    - 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생함.
        - **why?** → 각 중간 프락시 서버는 요청과 응답을 처리하는 과정에서 네트워크 통신, 프로토콜 변환, 인증, 암호화, 로깅, 필터링 등 추가적인 작업과 리소스를 사용함. 따라서 여러 프락시를 거치면 이 시간이 누적되어 전체 응답 속도가 느려짐.
- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 사용함.
    - **캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시가 할 수 있는 일**
        - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
        - URL에 근거하여 특정 부모 캐시를 동적으로 선택
        - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 탐색
        - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않음.
            - 인터넷 트랜짓 : 트래픽이 다른 네트워크로 건너가는 것
    - 형제 캐시 : 선택적인 피어링을 지원하는 캐시, 쉽게 말해 여러 캐시 서버가 서로의 캐시된 콘텐츠에 대해 부분적으로 접근할 수 있도록 허용하는 형태의 캐시 시스템
        - 피어링 : 네트워크 또는 캐시 시스템에서 비슷한 역할을 하는 다른 노드나 서버들과 직접 연결하여 자원을 서로 공유하고 통신하는 것
    - HTTP는 형제 캐시를 지원하지 않기 때문에, 인터넷 캐시 프로토콜(ICP)이나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장함.
      <img width="515" height="508" alt="image" src="https://github.com/user-attachments/assets/b5eacdcf-1033-4741-9d43-d80925447130" />


---

### 7.7 캐시 처리 단계

- **HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차**
    1. **요청 받기**
        - 캐시는 네트워크로부터 도착한 요청 메시지를 읽음.
        - 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작함.
    2. **파싱**
        - 메시지를 파싱하여 URL과 헤더들을 추출
    3. **검색**
        - 로컬 복사본이 있는지 검사
            - 로컬 복사본은 메모리 또는 디스크 또는 근처의 다른 컴퓨터에 저장되어 있을 수도 있음.
            - 캐시된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나, 얼마나 자주 사용되었는지 등에 대한 몇몇 메타데이터를 포함함.
        - 사본 X → 사본을 받아와서 로컬에 저장
    4. **신선도 검사**
        - 캐시된 사본이 충분히 신선한지 검사
        - 신선하지 X → 변경사항이 있는지 서버에 물어봄.
    5. **응답 생성**
        - 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성함.
            - 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있음.
                - ex) 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했다면, 캐시는 반드시 헤더를 적절하게 번역해야 함.
            - 캐시는 Date 헤더를 절대 조정해서는 안됨.
                - Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이기 때문
        - 새로운 헤더와 캐시된 본문으로 응답 메시지를 생성
    6. **발송**
        - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌.
    7. **로깅**
        - 대부분의 캐시는 각 캐시 트랜잭션이 완료된 후, 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 무엇이 일어났는지를 알려주는 항목을 추가함.
        - 가장 많이 쓰이는 캐시 로그 포맷 : 스퀴드 로그 포맷(Squid log format), 넷스케이프 확장 공용 로그 포맷(Netscape extended common log format)
    <img width="533" height="464" alt="image" src="https://github.com/user-attachments/assets/6112650c-c768-4528-b01e-939d41177c0a" />


---

### 7.8 사본을 신선하게 유지하기

- **문서 만료와 서버 재검사**
    - HTTP가 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘
- **문서 만료**
    - HTTP는 `Cache-Control`과 `Expires` 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌.
      <img width="524" height="222" alt="image" src="https://github.com/user-attachments/assets/6be89bd9-f6bc-4298-8bf7-122872d30ca9" />

    - 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우함.
      <img width="530" height="303" alt="image" src="https://github.com/user-attachments/assets/dcd99143-74ce-44fa-a51d-8fb9071d2cec" />

- **서버 재검사**
    - 캐시 문서 만료 ≠ 캐시된 문서가 원 서버에 현재 존재하는 문서와 실제로 다르다
    - 캐시 문서 만료는 “이제 검사할 시간이 되었다.”는 것을 뜻함.
    - 재검사 결과
        - 콘텐츠 변경 **O** → 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌.
        - 콘텐츠 변경 **X** → 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신함.
    - **HTTP가 요구하는 캐시의 행동**
        - ‘충분히 신선한’ 캐시된 사본
        - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
        - 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
        - 경고 메시지가 부착된 캐시된 사본(부정확하다면)
- **조건부 메서드와의 재검사**
    - HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해줌.
        - 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것
    - 모든 조건부 헤더는 `If-`접두어로 시작함.
    - 캐시 재검사에 사용되는 조건부 헤더
        - `If-Modified-Since`(IMS)
            - 최근 변경 일시를 캐시 검사기로 사용
            
            ```jsx
            If-modified-Since: <캐시된 마지막 수정일>
            ```
            
            - 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 요청
            - 서버 응답 헤더의 `Last-Modified` 헤더와 함께 동작함.
            - 몇몇 웹 서버는 `If-Modified-Since`를 실제 날짜 비교로 구현하지 않고, IMS 날짜와 최근 변경일 간의 문자열 비교를 수행함.
                - 즉, “이 날짜 이후로 변경되었다면”이 아니라, “정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면”의 의미로 동작
                - ex) 일련번호를 최근 변경 일시로 사용하는 경우
              <img width="511" height="802" alt="image" src="https://github.com/user-attachments/assets/e9c57095-6aa3-48e7-9729-5156058d9131" />

        - `If-None-Match`(엔터티 태그 재검사)
            - 엔터티 태그를 캐시 검사기로 사용
            - **최근 변경 일시 재검사가 적절히 행해지기 어려운 상황**
                - 어떤 문서가 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있는 경우
                - 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있음. (ex. 철자나 주석의 변경)
                - 서버가 자신이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없는 경우
                - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있음.
                    - 쉽게 말해, 두 번의 갱신이 같은 초 안에 일어나면, 시간 정보 만으로는 갱신이 있었는지 구분하기 어려워서 캐시나 클라이언트가 최신 버전을 제대로 인식하지 못할 수 있음. → 따라서 매우 빠르게 변하는 데이터나 문서에는 1초보다 더 높은 정밀도(ex. 밀리초, 마이크로초) 단위의 시간 정보가 필요할 수 있음.
            - 엔터티 태그가 변경되면 캐시는 새 문서의 사본을 얻기(`GET`) 위해 `If-None-Match` 조건부 헤더를 사용 가능
              <img width="522" height="336" alt="image" src="https://github.com/user-attachments/assets/96bb698b-1fba-4ee2-a7f9-364594b9552a" />

            - 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 이 사실을 서버에게 알려주기 위해 하나의 `If-None-Match` 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있음.
                
                ```jsx
                If-None-Match: "v2.6"
                If-None-Match: "v2.4", "v2.5", "v2.6"
                If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
                ```
                
            - 서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있음.
                - **약한 검사기**
                    - 어느 정도 콘텐츠 변경을 허용하는 것
                    - 조건부 특정범위 가져오기 같은 몇몇 동작은 약한 검사기로는 불가능하기 때문에, 약한 검사기엔 `W/` 접두사를 붙임.
                        
                        ```jsx
                        ETag: W/"v2.6"
                        If-None-Match: W/"v2.6"
                        ```
                        
                    - HTTP/1.1은 콘텐츠가 변경되었더라도 “그 정도면 같은 것”이라고 서버가 주장할 수 있도록 해줌.
                - **강한 검사기**
                    - 콘텐츠가 바뀔 때마다 바뀜.
                    - 약한 엔터티 태그
                        - 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경돼야 함.
                    - 강한 엔터티 태그
                        - 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 함.
            - 엔터티 태그 값은 특정 리소스를 고유하게 식별하는 태그이므로, 다른 리소스에 대해서는 반드시 다른 값을 가져야 함.
                - `ETag` 값의 재활용 금지는 다른 리소스들이 동일한 캐시 검사를 갖지 않도록 보장해서 캐시 일관성과 정확성을 유지하기 위한 중요한 규칙임.
            - 캐시가 유효기간이 지나서 만료됐더라도 캐시 검사기를 사용한 “조건부 요청”은 계속 이루어질 수 있기 때문에, 캐시가 만료됐다는 이유만으로 이런 검사가 없을 거라고 단정해서는 안 됨.
            - **언제 엔터티 태그(`ETag`)를 사용하고 언제 `Last-Modified` 일시를 사용하는가?**
                - HTTP/1.1 클라이언트
                    - 만약 서버가 엔터티 태그(`ETag`)를 응답에 반환했다면, 클라이언트는 조건부 요청 시 반드시 `If-None-Match`를 사용해야 함.
                    - 만약 서버가 `Last-Modified` 값만을 반환했다면, 클라이언트는 `If-Modified-Since` 검사를 사용 가능
                    - 만약 서버가 `ETag`와 `Last-Modified`를 모두 지원한다면, 클라이언트는 HTTP/1.0과 HTTP/1.1 환경 모두에서 호환되도록 두 가지 검사 방식을 모두 사용해야 함.
                - HTTP/1.1 원 서버
                    - 실현 불가능하지만 않다면 엔터티 태그 검사기를 보내야 함.
                        - 엔터티 태그는 강한 엔터티 태그 대신 약한 엔터티 태그를 보내도 됨.
                        - 엔터티 태그와 함께 `Last-Modified` 값을 같이 보내는 것도 선호됨.
                    - 만약 HTTP/1.1 캐시나 서버가  `If-Modified-Since`와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 **모든** 조건부 헤더 필드의 조건을 만족할 때만 `304 Not Modified` 응답을 반환해야 함.

---

### 7.9 캐시 제어

- **서버가 캐시 기간을 설정할 수 있는 방법**
    - `Cache-Control: no-store` 헤더를 응답에 첨부
    - `Cache-Control: no-cache` 헤더를 응답에 첨부
    - `Cache-Control: must-revalidate` 헤더를 응답에 첨부
    - `Cache-Control: max-age` 헤더를 응답에 첨부
    - `Expires` 날짜 헤더를 응답에 첨부
    - 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인 방법으로 결정
- **캐시 제어 헤더**
    - `no-cache`
        - 로컬 캐시 저장소에 저장될 수 있지만, 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공 금지
        
        ```jsx
        Cache-Control: no-cache
        ```
        
    - `no-store`
        - 캐시가 그 응답의 사본을 만드는 것을 금지
        - 프락시 서버처럼 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제함.
        
        ```jsx
        Cache-Control: no-store
        ```
        
    - `Max-Age`
        - 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간(s)
        - `s-maxage` : `max-age`처럼 행동하지만 공용 캐시에만 적용됨.
        - `maximum aging`을 0으로 설정하면 캐시가 매 접근마다 문서를 캐시하지 않거나 혹은 매 접근마다 리프레시 하도록 요청할 수 있음.
        
        ```jsx
        Cache-Control: max-age=3600
        Cache-Control: s-maxage=3600
        ```
        
    - `Expires`
        - 더 이상 사용하지 않기를 권하는 응답 헤더
        - 초 단위의 시간 대신 실제 만료 날짜를 명시
        
        ```jsx
        Expires: Fri, 05 Jul 2002, 05:00:00 GMT
        ```
        
    - `Must-Revalidate`
        - 캐시가 해당 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미
        
        ```jsx
        Cache-Control: must-revalidate
        ```
        
    - 휴리스틱 만료
        - 만약 응답이 `Cache-Control: max-age` 헤더나 `Expires` 헤더 중 어느 것도 포함하지 않는다면, 캐시는 경험적인 방법으로 최대 나이를 계산함.
- **클라이언트 신선도 제약**
    - 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 가지고 있음.
    - 리프레시 버튼은 `Cache-Control` 요청 헤더가 추가된 `GET` 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴.
    - Cache-Control 요청 지시어
      
      <img width="531" height="503" alt="image" src="https://github.com/user-attachments/assets/e059bb8a-aa75-47c2-ac20-fb89046464f6" />
