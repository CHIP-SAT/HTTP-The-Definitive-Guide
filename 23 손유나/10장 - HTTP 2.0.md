### 10.1 HTTP/2.0의 등장 배경

- **SPDY 프로토콜**
    - 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것
    - 헤더를 압축하여 대역폭을 절약하고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄임.
    - 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖춤.
    - SPDY를 적용했을 때 RTT가 20ms인 상황에서는 12.34%의 성능 개선 효과가 있었으며, 80ms인 상황에서는 23.85%, 200ms인 상황에서는 26.79%의 성능 개선 효과가 있었음.
- HTTP/2.0은 SPDY를 기반으로 만들어짐.
    - SPDY와 비교하여 크게 변경된 점은 헤더를 압축할 때 더 이상 deflate 알고리즘을 사용하지 않게 되었다는 것
  
---

### 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작함.
- HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383 바이트) 한 개 이상의 프레임에 담기고, 이때 HTTP 헤더는 압축되어 담김.
- 프레임에 담긴 요청과 응답은 스트림을 통해 보내짐.
    - 한 개의 스트림은 한 쌍의 요청과 응답을 처리
    - 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리 가능
    - HTTP/2.0은 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공함.
- 기존 웹 애플리케이션들과 호환성을 최대로 유지하기 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지함.
    
    
    | HTTP/1.1 | HTTP/2.0 |
    | --- | --- |
    | Content-Length | :content-length |
    | 404 Not Found | 404 값을 갖고 있는 :status |
  
---

### 10.3 HTTP/1.1과의 차이점

- **프레임**
    - HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송됨.
    - 프레임의 구조
        - 모든 프레임은 8바이트 크기의 헤더 + 최대 16383바이트 크기의 페이로드
          <img width="510" height="344" alt="image" src="https://github.com/user-attachments/assets/54e34e02-fb22-40a3-a40d-bee7a7faf080" />

- **스트림과 멀티플렉싱**
    - 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청을 동시에 보낼 수 있기 때문에 회전 지연 문제를 해결할 수 있음.
    - 스트림은 우선순위를 가질 수 있지만, 요청이 우선순위대로 처리된다는 보장은 없음.
    - 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 가짐.
        - 클라이언트에 의해 초기화된 스트림의 식별자: 홀수
        - 서버에 의해 초기화된 스트림의 식별자: 짝수
        - 새로 만들어지는 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야 함.
    - 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 생성 ⇒ 스트림을 만들 때 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미
    - HTTP/2.0 커넥션에서 한 번 사용한 스트림 식별자는 재사용 불가능
    - 동시에 여러 개의 스트림을 사용하면 스트림이 블록될 우려가 있지만, HTTP/2.0은 `WINDOW_UPDATE` 프레임을 이용한 흐름 제어를 통해 스트림들이 서로 간섭해서 망가지는 것을 막아줌.
- **헤더 압축**
    - HTTP/2.0 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송됨.
    - 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원함.
    - HPACK은 헤더를 압축하고 해제할 때 압축 콘텍스트를 사용하기 때문에 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야 함.
- **서버 푸시**
    - 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 함.
        - ex) HTML 문서를 요청 받은 서버는 그 HTML 문서가 링크하고 있는 이미지, CSS 파일, 자바스크립트 파일 등의 리소스를 클라이언트에게 푸시 ⇒ 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하게 되는 트래픽과 회전 지연을 줄여줌.
    - 리소스를 푸시하려면 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 `PUSH_PROMISE` 프레임을 보내어 미리 알려줘야 함.
        - 클라이언트가 `PUSH_PROMISE` 프레임을 받게 되면 해당 프레임의 스트림은 ‘예약됨’ 상태가 됨.
        - 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안됨.
        - 스트림을 거절하려면? → 클라이언트에서 `RST_STREAM` 프레임을 전송
    - **서버 푸시 사용 시 주의할 점**
        - 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않거나, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수도 있음.
        - 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
        - 서버가 보내는 `PUSH_PROMISE` 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내짐.
        - 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정잭에 따라 검사해야 함.
            - ex) `example.org`로의 HTTP/2.0 커넥션은 `www.example.org`로부터의 푸시 응답을 허용하지 않음.
        - 서버 푸시를 끄고 싶다면 `SETTINGS_ENABLE_PUSH`을 0으로 설정하면 됨.
  
---

### 10.4 알려진 보안 이슈

- **중개자 캡슐화 공격**
    - HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩 ⇒ 헤더 필드로 줄바꿈 문자열을 포함하여 어떤 문자열이든 사용할 수 있게 함.
    - 이는 정상적인 HTTP/2.0 요청이나 응답이, 불법적이거나 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있음.
- **긴 커넥션 유지로 인한 개인정보 누출 우려**
    - HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있음. ⇒ 개인 정보 유출에 악용될 가능성 있음.
    - ex) 어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성이 있음.
