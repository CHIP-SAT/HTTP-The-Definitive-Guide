### 11.1 개별 접촉

- **HTTP의 stateless**
    - HTTP는 연결 자체에 대한 정보를 가지지 않으며 매 요청은 일회성이고 독립적으로 처리됨.

---

### 11.2 HTTP 헤더

- 사용자에 대한 정보를 전달하는 HTTP 헤더

  <img width="565" height="531" alt="image" src="https://github.com/user-attachments/assets/0087f047-9570-4e78-8418-dd2f855fd5de" />

---

### 11.3 클라이언트 IP 주소

- 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있음.
- **클라이언트 IP 주소로 사용자를 식별하는 방식의 약점**
    - 클라이언트 IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리키기 때문에 여러 사용자가 같은 컴퓨터를 사용한다면 식별 불가능
    - 많은 ISP는 사용자가 로그인하면 동적으로 IP 주소를 할당함. → 로그인한 시간에 따라 사용자는 매번 다른 주소를 받기 때문에 식별 불가능
    - NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고, 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변환함.
    - 보통 HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 하는데, 이 경우 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 봄.
        - 실제 클라이언트 IP 주소를 전달하기 위한 확장 헤더: `Client-ip`, `X-Forwarded-For`
          <img width="598" height="216" alt="image" src="https://github.com/user-attachments/assets/b7b38a79-2b6e-426b-9886-b99352b42117" />
        


---

### 11.4 사용자 로그인

- 서버에서, 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 `HTTP 401 Login Required` 응답 코드를 브라우저에 전송 → 브라우저는 로그인 대화상자를 보여주고, 다음 요청부터 `Authorization` 헤더에 그 정보를 기술하여 보냄.
   <img width="523" height="607" alt="image" src="https://github.com/user-attachments/assets/83751dee-19cc-45be-805e-7c07eb28bb2a" />



---

### 11.5 뚱뚱한 URL

- **뚱뚱한 URL**: 사용자의 상태 정보를 포함하고 있는 URL
- 사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킴.
- 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이디와 관련된 추가적인 정보(쇼핑 카트, 프로필 등)를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꿈.
- **뚱뚱한 URL의 문제**
    - 못생긴 URL
    - 공유하지 못하는 URL
    - 캐시 사용 불가
    - 서버 부하 가중
    - 이탈
    - 세션 간 지속성의 부재

---

### 11.6 쿠키

- 쿠키는 캐시와 충돌할 수 있기 때문에, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음.
- **쿠키의 타입**
    - **세션 쿠키**
        - 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
        - 사용자가 브라우저를 닫으면 삭제됨.
    - **지속 쿠키**
        - 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있음.
            - 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하기 위해 사용
    - **세션 쿠키와 지속 쿠키의 다른 점**: 파기되는 시점
        - `Discard` 파라미터가 설정돼 있거나, `Expires` 혹은 `Max-Age` 파라미터가 없으면 세션 쿠키
- **쿠키는 어떻게 동작하는가**
    - 쿠키는 서버가 사용자에게 `“안녕, 내 이름은..”`라고 적어서 붙이는 스티커와 같음.
    - 사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있음.
    - 웹 서버는 사용자를 식별하기 위한 유일한 값을 쿠키에 할당함.
        - 쿠키는 임의의 `이름=값` 형태의 리스트를 가지고, 그 리스트는 `Set-Cookie` 혹은 `Set-Cookie2` 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달함.
    - 쿠키는 어떤 정보든 포함 가능
    - 브라우저는 서버로 온 `Set-Cookie` 혹은 `Set-Cookie2` 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장함.
    - 사용자에게 쿠키 할당
      
      <img width="550" height="604" alt="image" src="https://github.com/user-attachments/assets/8ce030d0-a8eb-47fa-bd07-26cd3e158520" />
      
- **쿠키 상자**: 클라이언트 측 상태
    - 쿠키의 기본적인 발상: 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것
    - 클라이언트 측 상태(HTTP 상태 관리 체계): 브라우저가 쿠키 정보를 저장할 책임이 있는 것
    - **각 브라우저는 각기 다른 방식으로 쿠키를 저장함.**
        - 구글 크롬 쿠키
            - Cookies라는 SQLite 파일에 쿠키를 저장
        - 마이크로소프트 인터넷 익스플로러 쿠키
            - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장
- **사이트마다 각기 다른 쿠키들**
    - 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달함.
        - ex) `joes-hardware.com`에서 생성된 쿠키는 `joes-hardware.com`에만 보내고 `bobs-books.com`이나 `marys-movie.com`에는 보내지 않음.
    - **쿠키 Domain 속성**
        - 서버는 쿠키를 생성할 때 `Set-Cookie` 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어 가능
            
            ```jsx
            Set-Cookie: user="mary17"; domain="airtravelbargains.com"
            ```
            
            ⇒ 브라우저가 `user="mary17"`이라는 쿠키를 `.airtravelbargains.com` 도메인을 가지고 있는 모든 사이트에 전달한다는 의미
            
    - **쿠키 Path 속성**
        - 웹 사이트 일부에만 쿠키 적용 가능
        - path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키 전달 가능
            
            ```jsx
            Set-Cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/
            ```
            
            ⇒ 만약 사용자가 `http://www.airtravelbargains.com/specials.html` 에 접근하면 `Cookie: user="mary17"`의 쿠키만 얻게 됨. 하지만 사용자가 `http://www.airtravelbargains.com/autos/cheapo/index.html`로 접근하면 `Cookie: user="mary17"` , `Cookie: pref=compact` 두 개의 쿠키를 얻게 됨.
            
    - **쿠키 구성요소**
        - 현재 사용되는 쿠키 명세
            - Version 0(넷스케이프) 쿠키
                - Set-Cookie 속성
              
                  <img width="550" height="1008" alt="image" src="https://github.com/user-attachments/assets/7c1621d9-17fe-4b82-8e8b-bb2735fca54c" />
                  
                  <img width="525" height="919" alt="image" src="https://github.com/user-attachments/assets/9ff85d40-c65e-4cff-aa72-d50932f12862" />

                - Cookie 헤더
                    - 모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보냄.
                        
                        ```jsx
                        Cookie: session-id=002-1145265-8016838; session-id-time=1007884800
                        ```
                        
            - Version 1(RFC 2965) 쿠키
                - RFC 2965는 폐기되어 더 이상 지원되지 않음.
    - **쿠키와 세션 추적**
        - 쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용
        - `Amazon.com` 사이트는 세션 쿠키를 이용해서 사용자를 추적함.
          <img width="571" height="922" alt="image" src="https://github.com/user-attachments/assets/7eb1cdc8-d17b-455e-864d-72a164b54bba" />

    - **쿠키와 캐싱**
        - 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것을 주의해야 함.
        - **캐시를 다루는 기본 원칙**
            - **캐시되지 말아야 할 문서가 있다면 표시하라**
                - 문서가 `Set-Cookie` 헤더를 제외하고 캐시를 해도 될 경우, 문서에 명시적으로 `Cache-Control: no-cache="Set-Cookie"`를 기술
                - 캐시를 해도 되는 문서에 `Cache-Control: public`을 사용하면 웹의 대역폭을 더 절약시켜줌.
            - **`Set-Cookie` 헤더를 캐시 하는 것에 유의하라**
                - 만약 응답이 `Set-Cookie` 헤더를 가지고 있으면, 본문은 캐시할 수 있지만 `Set-Cookie` 헤더를 캐시하는 것에는 주의해야함.
                    - **why?** ⇒ 같은 `Set-Cookie` 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패하기 때문
                - 어떤 캐시는 응답을 저장하기 전에 `Set-Cookie` 헤더를 제거하기 때문에, 그 캐시 데이터를 받는 클라이언트는 `Set-Cookie` 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있음.
                    - 해결: 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 `Set-Cookie` 헤더 값을 기술하도록 함.
                        - 원 서버는 `Cache-Control: must-revalidate, max-age=0` 헤더를 캐시된 문서에 추가함으로써 재검사가 일어나게 할 수 있음.
            - **Cookie 헤더를 가지고 있는 요청을 주의하라**
    - **쿠키, 보안 그리고 개인정보**
        - 원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있음.
