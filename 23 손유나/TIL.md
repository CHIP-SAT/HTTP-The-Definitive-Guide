> 학습 과정에서 생긴 궁금증이나 헷갈렸던 부분을 다시 정리한 문서입니다.

### Q. URL의 한계는?

URL은 리소스의 **이름(name)** 이 아니라 **위치(location)** 를 나타내는 주소이다. 즉, 특정 시점에 어떤 객체가 어디에 위치해 있는지를 알려주는 역할을 한다.
예를 들어, 구글 검색 결과에 `https://example.com/news/123`라는 링크가 노출되었다고 하자. 이후 해당 사용자가 게시글의 주소를 `https://example.com/archive/news/123`로 변경하면, 기존 URL은 더 이상 유효하지 않게 된다. 
이로 인해 검색 결과에 있는 기존 URL을 클릭하면 "페이지를 찾을 수 없습니다"라는 오류가 발생하게 된다.

이처럼 URL은 **리소스가 이동하면 접근할 수 없게 되는 한계가 있다.**
한번 리소스가 옮겨지면, 그 리소스를 참조하던 기존 URL은 더 이상 유효하지 않고, 해당 객체를 찾을 수단이 사라진다. 이러한 문제를 예방하는 이상적인 방법은 **객체의 위치와 관계없이 항상 같은 방식으로 객체 자체를 식별할 수 있는 고유 이름을 사용하는 것**이다. 이것이 바로 **URN (Uniform Resource Name)** 이다.

URN을 사용하면 리소스의 물리적인 위치가 바뀌더라도 리소스 자체를 식별할 수 있다.
또한, URL에 PURL (Persistent URL) 같은 기술을 적용하면 URN의 기능을 어느 정도 구현할 수도 있다.

---

### Q.현재는 HTTP/1.1만 사용되는가, 아니면 HTTP/2와 HTTP/3도 함께 사용되고 있는가?
2025년 7월 기준, W3Techs 통계에 따르면 전 세계 웹사이트 중 HTTP/2는 약 **33.3%**, HTTP/3는 약 **35.2%** 사용되고 있다.
이를 통해 HTTP/1.1만 사용되는 것이 아니라, HTTP/2와 HTTP/3까지 모두 병행해서 사용되고 있는 것을 확인할 수 있다.
<img width="848" height="299" alt="image" src="https://github.com/user-attachments/assets/cf6f3b04-8e87-4af9-8ec2-8a31594b2aa8" />

---

### Q. 개발자가 HTTP 버전을 직접 지정할 수 없다면, 실제로는 어떻게 다른 버전이 사용되는가?
HTTP 버전은 클라이언트와 서버 간 협상 과정에서 결정된다. 개발자가 직접 HTTP 요청의 버전을 명시적으로 지정할 수는 없지만,
**클라이언트 라이브러리의 설정**이나 **웹 서버의 설정**을 통해 어떤 버전을 사용할지 **간접적**으로 제어할 수 있다.
예를 들어, 웹 서버인 Nginx에서는 `nginx.conf` 파일에 `listen 443 ssl http2;` 같은 설정을 추가하면 HTTP/2를 활성화할 수 있다.

---

### Q. 구글이 개발한 SPDY는 HTTP/2와 같은 프로토콜인가?
구글의 SPDY 프로토콜은 HTTP/2 버전 그 자체는 아니지만, HTTP/2를 탄생시키는 데 **기초 기술 및 초안 역할을 했던 프로토콜**이다.
HTTP/2는 SPDY의 핵심 개념인 멀티플렉싱, 헤더 압축, 서버 푸시 등을 이어받아 표준으로 자리잡았다.

---

### Q. GET과 HEAD 메서드는 어떤 차이가 있는가?
GET 메서드는 **리소스의 전체 내용(본문+헤더)** 을 요청하지만, HEAD 메서드는 **리소스의 헤더 정보**만 요청한다.
예를 들어, GET 요청은 실제 웹페이지의 내용(HTML, 이미지, JSON 등)을 포함하여 전체 리소스를 받아오고,
HEAD 요청은 그 리소스가 존재하는지 확인하거나, 메타 정보(예: `Content-Length`, `Content-Type`, `Last-Modified` 등) 만을 확인할 때 사용된다.

즉, HEAD는 서버 상태 확인, 캐시 유효성 검사, 파일의 크기 확인 등 성능 최적화 목적으로 사용되는 메서드이다.
