- HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됐으며, 애플리케이션 간에 서로 다른 프로토콜을 상호 운용하는 용도로 사용하기도 함.

### 8.1 게이트웨이

- **게이트웨이** : 리소스와 애플리케이션을 연결하는 역할
    - 요청을 받고 응답을 보내는 포털 같이 동작
    - 동적인 콘텐츠를 생성하거나 데이터 베이스에 질의를 보낼 수 있음.
    - HTTP 트래픽을 다른 프로토콜로 **자동으로 변환**하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 함.
- 웹 게이트웨이는 한 쪽에서는 HTTP로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신함.
    
    ```jsx
    <클라이언트 프로토콜>/<서버 프로토콜>
    ```
    
    - ex) 게이트웨이가 `HTTP` 클라이언트와 `NNTP` 뉴스 서버 사이에 있으면 `HTTP/NNTP` 게이트웨이가 됨.
    - **서버 측 게이트웨이** : 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신
    - **클라이언트 측 게이트웨이** : 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신

---

### 8.2 프로토콜 게이트웨이

- `gw1.joes-hardware.com`을 모든 `FTP` URL에 대한 `HTTP/FTP` 게이트웨이로 설정할 경우, 브라우저는 일반 `HTTP` 트래픽은 원 서버로 바로 보내고 `FTP` URL을 포함한 요청은 `gw1.joes-hardware.com` 게이트웨이로 `HTTP` 요청을 보냄.
  <img width="537" height="606" alt="image" src="https://github.com/user-attachments/assets/6d8bbe34-eb67-4802-a583-87f1d69118b2" />

- `HTTP/*`: 서버 측 웹 게이트웨이
    - 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에, 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환
- `HTTP/HTTPS`: 서버 측 보안 게이트웨이
    - 기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공
      <img width="562" height="371" alt="image" src="https://github.com/user-attachments/assets/a803ad48-777a-4fa3-99a9-b343e23425e5" />

- `HTTPS/HTTP`: 클라이언트 측 보안 가속 게이트웨이
    - 웹 서버의 앞단에 위치하여, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 함.
    - 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 생성
      <img width="560" height="447" alt="image" src="https://github.com/user-attachments/assets/aff8a31c-a953-4af4-90e8-e0497272680c" />

    - 장점 : 원 서버의 부하를 줄여줌.

---

### 8.3 리소스 게이트웨이

- 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 **서버 측 게이트웨이**임.
- **CGI**(Common Gateway Interface)
    - 최초의 API
    - 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합
- **서버 게이트웨이 애플리케이션의 동작**

  <img width="543" height="529" alt="image" src="https://github.com/user-attachments/assets/cd91ce4d-b903-4632-9a79-cf1ccd8686ab" />

- **Fast CGI의 등장 배경**
    - CGI는 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 **부하**가 크고, CGI를 사용하는 서버의 **성능을 제한**하며 서버 장비에 **부담**을 주는 문제가 있음.
    - Fast CGI는  **데몬**으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능 저하 문제를 해결함.
- **서버 확장 API**
    - 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 함.

---

### 8.4 애플리케이션 인터페이스와 웹 서비스

- **애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나** : 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일
- 웹 서비스는 SOAP을 통해 XML을 사용하여 정보를 교환함.
    - SOAP : HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준
    - XML : 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공

---

### 8.5 터널

- **웹 터널을 사용하는 이유** : HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위함.
- **웹 터널**
    - HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공
- **`CONNECT`로 HTTP 터널 커넥션 맺기**
    - 웹 터널은 HTTP의 `CONNECT` 메서드를 사용하여 커넥션을 맺음.
    - `CONNECT` 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 **TCP 커넥션**을 맺고 클라이언트와 서버 간에 오는 데이터를 **무조건 전달**하기를 요청함.
    - SSL 터널을 연결하기 위해 사용되는 `CONNECT`
      <img width="583" height="901" alt="image" src="https://github.com/user-attachments/assets/e0c247b9-2afa-4241-acaa-e5a75deb229a" />

    - `CONNECT` 요청
        
        ```jsx
        CONNECT home.netscape.com:443 HTTP/1.0
        User-agent: Mozilla/4.0
        ```
        
        - 요청 URI는 호스트 명이 대신함.
    - `CONNECT` 응답
        
        ```jsx
        HTTP/1.0 200 Connection Established
        Proxy-agent: Netscape-Proxy/1.1
        
        ```
        
        - 편의상 응답에 있는 사유 구절은 `Connection Established`로 기술됨.
        - 일반적인 HTTP 응답과 달리 `Content-Type` 헤더를 포함할 필요 X
            - 커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문
- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 X
    - 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있음.
- 클라이언트는 성능을 높이기 위해 `CONNECT` 요청을 보낸 다음, **응답을 받기 전에 터널 데이터를 전송 가능**
- 웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발됨.
    - SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않음.
    - 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있음.
        - 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해주므로
    - **직접 SSL 커넥션 vs 터널링된 SSL 커넥션**

      <img width="564" height="916" alt="image" src="https://github.com/user-attachments/assets/7ce5428f-b955-4d6c-ad93-18dc7d2ab4c4" />

- 게이트웨이는 터널 사용 허가를 내리기 전에 **프락시 인증**을 할 수 있음.
  <img width="573" height="900" alt="image" src="https://github.com/user-attachments/assets/c35a6b17-2292-459f-a135-53e647178382" />

- 보통 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없기 때문에, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함.

---

### 8.6 릴레이

- **HTTP 릴레이** : HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프락시
- 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달함.
- `Connection` 헤더를 지원하지 않고 한 가지 작업만 하는 단순 맹목적 릴레이는 행(hang)에 걸릴 수 있음.
  <img width="561" height="567" alt="image" src="https://github.com/user-attachments/assets/e91b8f23-9d3c-4cd3-809c-2631db570532" />
